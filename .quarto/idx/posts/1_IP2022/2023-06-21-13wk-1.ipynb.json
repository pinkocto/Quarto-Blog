{"title":"13wk-1: 깊은복사와 얕은복사","markdown":{"yaml":{"title":"13wk-1: 깊은복사와 얕은복사","author":"최규빈","date":"06/21/2023"},"headingText":"강의영상","containsRefs":false,"markdown":"\n\n> 모르고 살았다면 더 좋았을 내용 \n\n\n> youtube: <https://youtube.com/playlist?list=PLQqh36zP38-x1VTi4A3DVjHwcc56J9mwj>\n\n# import\n\n# Introduction\n\n## 예제1: 비상식적인 append \n\n> 포인트: 이상한 일의 관찰 \n\n`-` 원소의 추가: `+` 이용 \n\n`-` 원소의 추가 `.append` 이용\n\n## append의 동작원리: 틀린상상 \n\n`-` 상자로서의 변수: 변수가 데이터를 저장하는 일종의 상자와 같다. <-- 아주 흔한 오해 (Fluent Python)\n\n> 흔히 비유하는 '상자로서의 변수' 개념이 실제로는 객체지향적 언어에서 참조변수를 이해하는 데 방해가 된다. \n\n`-` \"상자로서의 변수\" 관점에서 아래의 코드를 해석하자. (일단 아래의 해석들이 틀린해석이라는 사실을 명심할 것)\n\n```python\na=[1,2,3]\nb=a\na.append(4)\n```\n\na,b라는 변수들은 메모리에 어떻게 저장이 되어있을까? \n\n상상력을 조금 발휘하면 아래와 같이 여길 수 있다. \n\n(1) 메모리는 변수를 담을 방이 여러개 있는 호텔이라고 생각하자. \n\n(2) 아래를 실행하였을 경우 \n```python\na=[1,2,3]\n```\n- 메모리주소1에 존재하는 방을 a라고 하고, 그 방에 [1,2,3]을 넣는다. \n\n(3) 아래를 실행하였을 경우 \n```python\nb=a\n```\n- 메모리주소2에 존재하는 방을 b라고 하고, 그 방에 a를 넣어야하는데, a는 [1,2,3]이니까 [1,2,3]을 넣는다. \n\n(4) 아래를 실행하면 \n```python\na.append(4)\n```\n- 방 a로가서 [1,2,3]을 [1,2,3,4]로 바꾼다. \n- 그리고 방 b에는 아무것도 하지 않는다. \n\n`-` R에서는 맞는 비유인데, 파이썬은 적절하지 않은 비유이다. \n\n### 틀린이유 \n\n## append의 동작원리: 올바른 상상 \n\n> 파이썬에서의 변수는 자바에서의 참조변수와 같으므로 변수는 객체에 붙은 레이블이라고 생각하는 것이 좋다. \n\n`-` 파이썬에서는 아래가 더 적절한 비유이다. \n\n(1) 메모리는 변수를 담을 방이 여러개 있는 호텔이라고 생각하자. \n\n(2) 아래를 실행하였을 경우 \n```python\na=[1,2,3]\n```\n- 메모리주소 `139753545242336`에서 [1,2,3]을 생성\n- 방 `139753545242336`의 방문에 `a`라는 포스트잇을 붙인다. \n- 앞으로 [1,2,3]에 접근하기 위해서는 여러 메모리방중에서 `a`라는 포스트잇이 붙은 방을 찾아가면 된다. \n\n(3) 아래를 실행하였을 경우 \n```python\nb=a\n```\n- `a`라는 포스트잇이 지칭하는 객체를 가져옴. 그리고 그 객체에 `b`라는 포스트잇을 붙인다. \n- 쉽게말하면 `b`라는 포스트잇을 방 `139753545242336`의 방문에 붙인다는 이야기. \n- 앞으로 [1,2,3]에 접근하기 위해서는 여러 메모리방중에서 `a`라는 포스트잇이 붙어 있거나 `b`라는 포스트잇이 붙어있는 방을 찾아가면 된다. \n\n(4) 아래를 실행하면 \n```python\na.append(4)\n```\n- `a`라는 포스트잇이 붙어있는 방으로 가서, 그 내용물에 `append`함수를 적용하여 4를 추가하라. 즉 내용물 [1,2,3]을 [1,2,3,4]로 바꾸라. \n- 같은방(`139753545242336`)에 `a`,`b`라는 포스트잇이 모두 붙어있음. 따라서 `b`라는 포스트잇이 붙은 방을 찾아가서 내용물을 열어보면 [1,2,3,4]가 나온다. \n\n# 할당문(=)의 이해 \n\n`-` 파이썬에서 할당문을 이해하기 위해서는 언제나 오른쪽을 먼저 읽어야 한다. \n\n- 할당문의 오른쪽에서는 객체를 \"생성\"하거나 \"가져옴\"\n- 그 후에 라벨을 붙이듯이 할당문 왼쪽의 변수가 할당문 오른쪽의 객체에 바인딩 된다. (참조)\n\n`-` `b=a`는 \n\n> 나는 이미 a가 의미하는게 무엇인지 알고있어. 그런데 그 실체를 b라고도 부르고 싶어. \n\n라는 것과 같다. 즉 이미 `a`라고 부르고 있는것을 내가 `b`라고도 부르고 싶다는 의미인데 이는 마치 별명과 같다. (`b`는 `a`의 별명, alias) 그리고 이처럼 하나의 오브젝트에 여러개의 이름을 붙이는 것을 에일리어싱이라고 부른다. \n\n# id, value \n\n## 예제1: 같은 value, 다른 id\n\n> 포인트: (1) 포스트잇 개념의 확실한 이해 (2) 할당문을 새로운 시각으로 해석하는 연습 (3) \"생성->할당\"과 \"참조/에일리어싱\"의 구분\n\n여기에서 a,b,c는 모두 같은 value를 가진다. \n\n하지만 그 id까지 같은 것은 아니다. \n\n## 예제2\n\n> 선행지식: \"생성->할당\" 과 \"참조/에일리어싱\"의 구분\n\n> 포인트: 재할당의 이해!!\n\n(관찰)\n\n(해설)\n\n- 포인트: [1,2,3]+[4] 가 실행되는 순간 새로운 오브젝트가 만들어지고 그 오브젝트를 a라는 이름으로 다시 할당되었음. (재할당)\n\n# 인터닝 \n\n## 예제1\n\n> 선행지식: \"생성->할당,재할당\" 과 \"참조/에일리어싱\"의 구분\n\n> 포인트: 인터닝을 위한 떡밥예제\n\n- 당연한결과임. \n\n## 예제2: 이제 다 이해했다고 생각했는데.. \n\n> 선행지식: \"생성->할당,재할당\" 과 \"참조/에일리어싱\"의 구분\n\n> 포인트: 인터닝의 이해\n\n- id(a)와 id(b)가 왜 똑같지..? \n\n(해설) 파이썬의 경우 효율성을 위해서 -5~256까지의 정수를 미리 저장해둠. \n\n- 3은 언제나 7394720에 지박령마냥 밖혀있음 \n\n# `.copy()`의 사용 (shallow copy의 사용)\n\n> 선행지식: \"생성->할당,재할당\" 과 \"참조/에일리어싱\"의 구분\n\n> 포인트: \"생성->할당,재할당\" 과 \"참조/에일리어싱\"의 연습, 복사를 위한 떡밥예제\n\n## 예제1\n\n(관찰) 아래의 예제를 살펴보자. 참조를 제대로 이해했다면 아래의 예제는 자연스럽게 이해가능할 것임. \n\n(해설)\n\n이해는 되지만 우리가 원한건 이런게 아니야 \n\n## 예제2: R과 같이 = 를 쓰고 싶다면? \n\n> 선행지식: \"생성->할당,재할당\" 과 \"참조/에일리어싱\"의 구분\n\n> 포인트: 복사의 사용, 얕은복사의 떡밥\n\n(관찰)\n\n(해설)\n\n## 예제3: 이제 다 이해했다고 생각했는데.. \n\n> 선행지식: \"생성->할당,재할당\" 과 \"참조/에일리어싱\"의 구분, 복사의 사용\n\n> 포인트: 얕은복사를 이해하지 못할때 생기는 개념충돌 \n\n(관찰)\n\n(의문)\n\n- l1이랑 l2의 주소도 다르게 나오는데 왜 또 참조한것마냥 l1과 l2가 같이 바뀌고 있지? \n\n***나는 진정한 복사(=깊은복사)를 하고싶다***\n\n# Shallow copy의 이해\n\n`-` 방금 살펴본 예제3을 이해하기 위해서는 shallow copy를 이해해야 한다. \n\n## 예제1\n\n> 선행지식: 이전까지 모든것 \n\n> 포인트: 0차원 자료형의 메모리 구조 이해, 1차원 자료형의 메모리 구조를 위한 떡밥\n\n(관찰+해설)\n\n메모리 상황 \n\n1. 2222라는 오브젝트가 어떤공간(`139753545300880`)에 생성되고 그 공간에 `a`라는 라벨이 붙음 \n2. 2222라는 오브젝트가 어떤공간(`139753545301808`)에 생성되고 그 공간에 `b`라는 라벨이 붙음 \n\n즉 -5~256 이외의 2개의 메모리 공간을 추가적으로 사용 \n\n## 예제2\n\n> 선행지식: 이전까지 모든것, 0차원 자료형의 메모리저장상태 이해 \n\n> 포인트: (1) 1차원 자료형의 메모리 구조 이해 (2) 가변형객체라는 표현의 의미 \n\n(관찰)\n\n(해설)\n\n메모리상황 \n\n0. -5~256까지의 숫자는 미리 메모리에 저장되어 있다. 이중에서 1은 `7394656`, 2는 `7394688`에 저장되어있음. \n1. 2222가 공간 `139753178093776`에서 만들어진다. \n2. 어떠한 리스트오브젝트가 공간 `139753182327904`에서 만들어지고 원소로 [1,2,2222]를 가진다. 이 공간에 `a`라는 포스트잇을 붙인다. \n3. 2222가 공간 `139753178095568`에서 만들어진다.\n4. 어떠한 리스트오브젝트가 공간 `139753173818656`에서 만들어지고 원소로 [1,2,2222]를 가진다. 이 공간에 `b`라는 포스트잇을 붙인다. \n5. `a`라는 포스트잇이 붙은 공간으로 이동하여 원소에 4를 추가시킨다. \n\n즉 -5~256이외에 4개의 메모리 공간을 추가사용 (a,b,a의 2222,b의 2222)\n\n## 예제3\n\n> 선행지식: 이전까지 모든 것\n\n> 포인트: `l2=l1` 와 `l2=l1.copy()` 의 차이점\n\n(관찰)\n\n(해설)\n\n메모리상황 \n\n0. -5~256까지의 숫자가 메모리에 저장되어 있다. \n1. 저장된 숫자중 66,55,44를 묶어서 리스트로 구성하고 이 리스트를 공간 `139753183707216`에 저장. \n2. 숫자 3과 공간 `139753183707216`에 저장된 리스트 [66,55,44]를 하나로 묶어서 새로운 리스트를 구성하고 이를 공간 `139753183437040`에 저장. 공간 `139753183437040`에 `l1`이라는 포스트잇 생성. \n3. 공간 `139753182311120`에 `l1`의 원소들을 모아서 새로운 리스트를 구성함. 공간 `139753182311120`에 `l2`라는 포스트잇 생성. 그런데 따져보니까 내부구성은 똑같아?\n\n0. l1[0]은 원래 공간 `7394720`와 binding 되어 있었음.  \n1. 그런데 7777이라는 새로운 오브젝트가 공간 `139753178092080`에 생성되고 l1[0]이 공간 `139753178092080`와 다시 binding 됨. \n\n## 예제4\n\n> 선행지식: 이전까지 모든것, `.copy()`의 동작원리 \n\n> 포인트: `.copy()`의 동작원리 재학습\n\n(관찰)\n\n(해설)\n\n## 예제5: 우리를 힘들게 했던 그 예제. \n\n> 선행지식: 이전까지 모든것, `.copy()`의 동작원리 \n\n> 포인트: (1) `.copy()`의 한계, (2) 얕은복사라는 명칭의 유래\n\n(관찰)\n\n(해설-시점1)\n\n(해설-시점2)\n\n해설: 사실 시점1에서 메모리 주소상황을 잘 이해했다면 신기한 일이 아니다. `.copy()`는 l1과 l2의 주소만 다르게 만들 뿐 내용물인 `l1[0]`,`l1[1]`는 동일하니까.\n\n## 예제6: 신임교수=['최규빈','이영미']\n\n> 선행지식: 이전까지의 모든것 \n\n> 포인트: 이전까지의 모든것 점검\n\n`-` 최규빈, 이영미는 신임교수임 \n\n`-` 신임교수를 누군가는 막내들이라고 부르기도 함. \n\n\"막내들\"이라는 단어와 \"신임교수\"라는 단어는 사실 같은 말임 \n\n`-` 새로운 교수 \"박혜원\"이 뽑혔음. \n\n`-` 전북대 통계학과에서 R특강팀을 구성하여 방학중 R교육을 실시하고자함. 특강팀은 우선 신임교수들로 구성. \n\n`-` R특강팀에 `최혜미`교수님 추가. (그렇지만 최혜미교수님이 막내는 아니야.. // 참조와 shallow copy의 차이점) \n\n`-` R특강팀에서 양성준 교수를 추가하여 파이썬 특강팀을 구성 (R특강팀의 구분을 위해서 중첩리스트 구조로 만들자)\n\n`-` 이영미교수는 다른 일이 많아서 R특강 팀에서 제외됨. (그럼 자연히 파이썬에서도 제외됨!!) \n\n하지만 이영미교수는 여전히 신임교수이면서 막내들임 \n\n`-` 새로운 교수로 \"손흥민\"이 임용됨. \n\n`-` 그렇다고 해서 손흥민 교수가 바로 R이나 파이썬 특강팀에 자동소속되는건 아님\n\n# Deep copy\n\n## 예제1: Motivation example\n\n`-` 아래의 상황을 다시 생각해보자.\n\n**이슈:** 이영미교수가 파이썬특강에서 제외되면서 ADSP특강팀에서도 제외되었음. 그런데 사실 이영미교수가 파이썬특강팀에서만 제외되길 원한 것이지 ADSP특강팀에서 제외되길 원한게 아닐수도 있음. \n\n**해결**: Deep copy의 사용\n\n## 예제2\n\n> 선행지식: 이전까지 모든것, 얕은복사 \n\n> 포인트: (1) 깊은복사 (2) 복사의 레벨을 이해 (3) 얕은복사 = 1단계 깊은복사\n\n`-` deepcopy\n\n- 레벨1: `l1`,`l2` 의 메모리 주소가 다름을 확인\n\n- 레벨2: `l1안에 있는 [66,[55,44]]`와 `l2안에 있는 [66,[55,44]]`의 메모리 주소가 다름도 확인. \n\n- 레벨3: `l1안의 [66,[55,44]] 안의 [55,44]`와 `l2안의 [66,[55,44]] 안의 [55,44]`의 메모리 주소까지도 다름을 확인. \n\n`-` 비교를 위한 shallow copy\n\n- 레벨1: `l1`,`l2` 의 메모리 주소가 다름을 확인\n\n- 레벨2: `l1안에 있는 [66,[55,44]]`와 `l2안에 있는 [66,[55,44]]`의 메모리 주소는 같음!!\n\n- 레벨3: `l1안의 [66,[55,44]] 안의 [55,44]`와 `l2안의 [66,[55,44]] 안의 [55,44]`의 메모리 주소도 같음!!\n\n`-` 비교를 위한 참조 \n\n- 레벨1: `l1`,`l2` 여기서부터 메모리 주소가 같다. \n\n> Note: 문헌에 따라서 shallow copy를 level1 deep copy라고 부르기도 한다. \n\n# Shallow copy 연습문제 \n\n## 예제1\n\n> 선행지식: 이전까지 모든것\n\n> 포인트: 얕은복사의 한계점 이해\n\n`-` 아래의 코드결과를 예측하라. 결과가 나오는 이유를 설명하라. \n\n- 포인트: shallow copy (=level 1 deep copy) 이므로 `l1안의 [66,55,44]`와 `l2안의 [66,55,44]`는 같은 메모리 주소를 가짐 \n\n## 예제2\n\n> 선행지식: 이전까지 모든것\n\n> 포인트: 재할당의 활용하여 얕은복사의 한계점 극복\n\n`-` 아래의 코드결과를 예측하라. 결과가 나오는 이유를 설명하라. \n\n- 포인트: `l1[-1]+[33]`가 실행되는 순간 새로운 오브젝트가 생성되고 이 새로운 오브젝트가 l1의 마지막 원소에 새롭게 할당된다. \n\n## 예제3\n\n> 선행지식: 이전까지 모든것\n\n> 포인트: 재할당의 활용하여 얕은복사의 한계점 극복, 예제4를 위한 떡밥\n\n- 포인트: 이 상황에서 `l1안의 [66,55,44]`와 `l2안의 [66,55,44]`는 서로 다른 메모리 주소를 가진다. \n\n## 예제4\n\n> 선행지식: 이전까지 모든것\n\n> 포인트: 재할당으로 인해 메모리주소가 틀어짐을 이용한 트릭예제, 예제5의 떡밥예제\n\n(잘못된 상상) 아래의 코드와 결과가 같을거야!!\n\n(하지만 현실은)\n\n## 예제5\n\n> 선행지식: 이전까지 모든것\n\n> 포인트: `+=`는 재할당이 아니다. \n\n***`+=` 연산자의 올바른 이해***\n\n> ??? 예제4랑 예제5는 같은코드가 아니었음!!! `a += [1]` 는 새로운 오브젝트를 만드는게 아니고, 기존의 오브젝트를 변형하는 스타일의 코드였음! (마치 append 메소드처럼) \n\n# 불변형 객체 \n\n## 예제1: Motivation example\n\n> 선행지식: 이전까지 모든것\n\n> 포인트: `+=`는 재할당이 아니다. \n\n`-` 우리는 이제 아래의 내용은 마스터함 \n\n`-` 아래의 결과를 한번 예측해볼까? \n\n## 해설 \n\n(시점1)\n\n(시점2)\n\n주소 `140006812590400:(66,55,44)`에 있는 값을 바꾸고 싶지만 불변형이라 못바꿈 $\\to$ 그냥 새로 만들자. 그래서 그걸 `140006813422272`에 저장하자. \n\n# Shallow-copy vs Deep-copy\n\n`-` 암기용문구: \"얕은복사는 껍데기만 복사한다. 깊은복사는 내부까지 복사한다.\"\n\n`-` 일부교재에서는 경우에 따라 얕은복사가 선호될 수 있다는 식으로 설명되어있으나 솔직히 대부분 코드에서 얕은복사의 동작을 정확하게 의도하고 코드를 사용하진 않는다. 대부분의 경우에서 얕은복사는 불필요한 side effect을 유발하는 쓸모없는 개념이라 생각한다. (복사를 이미 하려고 마음먹었으면 보통 깊은복사를 생각함, 그게 아니라면 차라리 참조를 썼겠지..)\n\n`-` 그럼 얕은복사의 장점은 무엇인가? 얕은복사가 깊은복사보다 메모리를 더 적게 사용한다. \n\n```Python\n## 예제1\nlst1 = ['양성준',['최규빈','이영미','최혜미']]\nlst2 = lst1.copy()\n## 예제2 \nlst1 = ['양성준',['최규빈','이영미','최혜미']]\nlst2 = copy.deepcopy(lst1)\n```\n\n- 예제1: 4+1+2 = 7개의 공간 사용 \n- 예제2: 4+2+2 = 8개의 공간 사용 \n\n**요약**\n\n`-` 파이썬은 메모리를 아끼기 위해서 얕은복사라는 이상한 행동을 한다. (하지만 우리는 보통 얕은복사를 원하지 않아. 우리는 깊은복사만 쓰고 싶음!) \n\n`-` 통찰1: 그런데 오묘하게도 [1,2,3,4,5,6]와 같이 1차원 리스트인 경우는 문제가 되지 않음. \n\n-  1차원 리스트의 경우(= 중첩된 리스트가 아닐 경우)는 \"레벨1 수준의 깊은복사\"만 있으면 충분하다. 따라서 \"shallow copy = deep copy\" 임.\n\n`-` 통찰2: 생각해보니까 모든 자료형이 불변형인 경우에도 문제가 되지 않음. (R은 모든 자료형이 불변형이다) \n\n`-` 문제상황요약: [[1,2],[3,4]] 와 같이 리스트에 리스트가 포함된 형태라면 문제가 생긴다. $\\to$ 그런데 우리가 자주 쓰는 매트릭스가 사실 이러한 중첩된 리스트 구조 아니야? 이거 문제인데? \n\n- 해결책1: 깊은복사를 하면 된다. (이미했음)\n- 해결책2: 넘파이를 쓰면된다. (이걸로 뭘 어떻게 개선한다는거야?)\n\n# numpy \n\n## 2차원의 실체 \n\n`-` 2차원 array a,b를 선언하자. \n\n`-` a,b,c,d 속성비교 \n\n`-` ((16, 8), (24, 8), (8, 8), (8,)) 와 같은 저 숫자들이 도데체 무엇을 의미하는거야?!\n\n- 사전지식: 컴퓨터는 하나의 숫자를 저장하는데 메모리를 8칸 쓴다. \n- 가정: 만약에 컴퓨터가 1차원으로만 숫자를 저장한다면?? \n- strides의 의미: (다음 행으로 가기위해서 JUMP해야하는 메모리 공간수, 다음 열로 가기위해서 JUMP해야하는 메모리 공간수) \n\n`-` 통찰: strides의 존재로 인해서 유추할 수 있는 것은 a,b,c,d 는 모두 1차원으로 저장되어있다는 사실이다. (중첩된 리스트꼴이 아니라)\n\n`-` 그렇다면.. shallow copy = deep copy?!\n\n`-` 해방: 넘파이를 쓰면 `copy.deepcopy()`를 쓰지 않아도 된다. \n\n`-` 용어정리: (필요할까..?)\n\n- numpy 한정 `.copy()` 는 copy모듈의 deep copy와 동등한 효과를 준다. 하지만 실제로는 shallow copy 이다. [공식문서](https://numpy.org/doc/stable/reference/generated/numpy.copy.html)에는 \"Note that np.copy is a shallow copy and will not copy object elements within arrays.\" 라고 명시되어 있음. \n- 일부 블로그에서 deep copy라고 주장하기도 함. [블로그1](https://humaneer.net/292), [블로그2](https://python.plainenglish.io/shallow-copy-and-deep-copy-in-python-numpy-8861e0870c5f), [블로그3](https://yeko90.tistory.com/entry/%EB%84%98%ED%8C%8C%EC%9D%B4-%EA%B8%B0%EC%B4%88-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC-copy-view) // 블로그2의 경우 참조와 shallow copy도 구분못함.. \n- 이따가 view라는 개념도 나올텐데 `.copy()`를 deep copy라고 주장하는 블로거들 대부분 `.view()`를 shallow copy 혹은 참조라고 주장한다. 하지만 copy와 view를 설명하는 [공식문서](https://numpy.org/doc/stable/user/basics.copies.html)에서는 view가 shallow copy라는 말을 찾아볼 수 없음. \n\n`-` 정리 (넘파이한정)\n\n- `nparray.copy()`: 실제로는 shallow copy, 그런데 느낌은 deep copy \n- `nparray.view()`: 실제로는 shallow copy 보다 더 얕은 단계의 카피, 그런데 느낌은 shallow copy\n\n## 참조 \n\n`-` a를 선언, b는 a의 참조\n\n`-` a의 shape을 바꾸어보자 $\\to$ b도 같이 바뀐다 \n\n## view \n\n`-` a를 선언, b는 a의 view\n\n`-` 그런데.. \n\n`-` 출생의 비밀 \n\n- ? 이거 바뀐 a아니야? \n\n`-` View \n\n- b가 a의 뷰라는 의미는, b가 a를 소스로하여 만들어진 오브젝트란 의미이다. \n- 따라서 이때 b.base는 a가 된다. \n- b는 자체적으로 데이터를 가지고 있지 않으며 a와 공유한다. \n\n`note1` 원본 ndarray의 일 경우는 .base가 None으로 나온다. \n\n`note2` b.base의 shpae과 b의 shape은 아무 관련없다. \n\n`-` numpy에서 view를 사용하는 예시 (transpose)\n\n- `X.T` 는 `X`의 view 이다.\n\n## copy \n\n`-` a를 선언, b는 a의 copy\n\n`-` a의 shape을 바꿔도 b에는 적용되지 않음 \n\n`-` 그리고 a[0]의 값을 바꿔도 b에는 적용되지 않음. \n\n`-` b의 출생을 조사해보니.. \n\n출생의 비밀은 없었다. 둘다 원본. \n\n`-` `.view()` 는 껍데기만 새로생성 //  `.copy()` 는 껍데기와 데이터를 모두 새로 생성 \n\n### ***Appendix: .copy의 한계(?)***\n\n(관찰)\n\n- 왜 또 시점2에서는 a와 b가 같이 움직여?\n\n***해결책: 더 깊은 복사***\n\n`-` 중간요약\n\n- 사실 `b=a.copy()`는 에서 `.copy()`는 사실 온전한 deep-copy가 아니다. \n- 그래서 `a`의 데이터가 중첩구조를 가지는 경우는 온전한 deep-copy가 수행되지 않는다. \n- 그런데 일반적으로 넘파이를 이용할때 자주 사용하는 데이터 구조인 행렬, 텐서등은 데이터가 중첩구조를 가지지 않는다. (1차원 array로만 저장되어 있음) \n- 따라서 행렬, 텐서에 한정하면 `.copy()`는 온전한 deep-copy라고 이해해도 무방하다. <-- 이것만 기억해!\n\n## 요약 \n\n아래를 구분할 수 있으면 잘 이해한 것!! \n\n```Python \narr = np.array(...) # arr -- [arr.shape, arr.strides, arr.base, ... ] \narr2 = arr \narr2 = arr.view()\narr2 = arr.copy()\narr2 = copy.deepcopy(arr)\n```\n\n## 별명, 뷰, 카피 \n\n`-` test 함수 작성 \n\n`-` 잘 동작하나? \n\n(테스트1) \n\n(테스트2) \n\n(테스트3) \n\n(테스트4) \n\n## 결론 \n\n`-` 참조, 뷰, 카피의 개념을 잘 알고 있고 때에 따라 메모리를 아끼면서 이들을 적절하게 사용하고 싶을것 같음. 하지만 이건 불가능한 소망임. \n\n`-` 우리가 사용했던 어떠한 것들이 뷰가 나올지 카피가 나올지 잘 모른다. (그래서 원리를 이해해도 대응할 방법이 사실없음) \n\n### 예시1\n\n### 예시2\n\n`-` 심지어 copy인줄 알았던것이 사실 view라서 원치않는 side effect이 생길수 있음. $\\to$ 그냥 방어적 프로그래밍이 최선인듯 \n","srcMarkdownNoYaml":"\n\n> 모르고 살았다면 더 좋았을 내용 \n\n# 강의영상 \n\n> youtube: <https://youtube.com/playlist?list=PLQqh36zP38-x1VTi4A3DVjHwcc56J9mwj>\n\n# import\n\n# Introduction\n\n## 예제1: 비상식적인 append \n\n> 포인트: 이상한 일의 관찰 \n\n`-` 원소의 추가: `+` 이용 \n\n`-` 원소의 추가 `.append` 이용\n\n## append의 동작원리: 틀린상상 \n\n`-` 상자로서의 변수: 변수가 데이터를 저장하는 일종의 상자와 같다. <-- 아주 흔한 오해 (Fluent Python)\n\n> 흔히 비유하는 '상자로서의 변수' 개념이 실제로는 객체지향적 언어에서 참조변수를 이해하는 데 방해가 된다. \n\n`-` \"상자로서의 변수\" 관점에서 아래의 코드를 해석하자. (일단 아래의 해석들이 틀린해석이라는 사실을 명심할 것)\n\n```python\na=[1,2,3]\nb=a\na.append(4)\n```\n\na,b라는 변수들은 메모리에 어떻게 저장이 되어있을까? \n\n상상력을 조금 발휘하면 아래와 같이 여길 수 있다. \n\n(1) 메모리는 변수를 담을 방이 여러개 있는 호텔이라고 생각하자. \n\n(2) 아래를 실행하였을 경우 \n```python\na=[1,2,3]\n```\n- 메모리주소1에 존재하는 방을 a라고 하고, 그 방에 [1,2,3]을 넣는다. \n\n(3) 아래를 실행하였을 경우 \n```python\nb=a\n```\n- 메모리주소2에 존재하는 방을 b라고 하고, 그 방에 a를 넣어야하는데, a는 [1,2,3]이니까 [1,2,3]을 넣는다. \n\n(4) 아래를 실행하면 \n```python\na.append(4)\n```\n- 방 a로가서 [1,2,3]을 [1,2,3,4]로 바꾼다. \n- 그리고 방 b에는 아무것도 하지 않는다. \n\n`-` R에서는 맞는 비유인데, 파이썬은 적절하지 않은 비유이다. \n\n### 틀린이유 \n\n## append의 동작원리: 올바른 상상 \n\n> 파이썬에서의 변수는 자바에서의 참조변수와 같으므로 변수는 객체에 붙은 레이블이라고 생각하는 것이 좋다. \n\n`-` 파이썬에서는 아래가 더 적절한 비유이다. \n\n(1) 메모리는 변수를 담을 방이 여러개 있는 호텔이라고 생각하자. \n\n(2) 아래를 실행하였을 경우 \n```python\na=[1,2,3]\n```\n- 메모리주소 `139753545242336`에서 [1,2,3]을 생성\n- 방 `139753545242336`의 방문에 `a`라는 포스트잇을 붙인다. \n- 앞으로 [1,2,3]에 접근하기 위해서는 여러 메모리방중에서 `a`라는 포스트잇이 붙은 방을 찾아가면 된다. \n\n(3) 아래를 실행하였을 경우 \n```python\nb=a\n```\n- `a`라는 포스트잇이 지칭하는 객체를 가져옴. 그리고 그 객체에 `b`라는 포스트잇을 붙인다. \n- 쉽게말하면 `b`라는 포스트잇을 방 `139753545242336`의 방문에 붙인다는 이야기. \n- 앞으로 [1,2,3]에 접근하기 위해서는 여러 메모리방중에서 `a`라는 포스트잇이 붙어 있거나 `b`라는 포스트잇이 붙어있는 방을 찾아가면 된다. \n\n(4) 아래를 실행하면 \n```python\na.append(4)\n```\n- `a`라는 포스트잇이 붙어있는 방으로 가서, 그 내용물에 `append`함수를 적용하여 4를 추가하라. 즉 내용물 [1,2,3]을 [1,2,3,4]로 바꾸라. \n- 같은방(`139753545242336`)에 `a`,`b`라는 포스트잇이 모두 붙어있음. 따라서 `b`라는 포스트잇이 붙은 방을 찾아가서 내용물을 열어보면 [1,2,3,4]가 나온다. \n\n# 할당문(=)의 이해 \n\n`-` 파이썬에서 할당문을 이해하기 위해서는 언제나 오른쪽을 먼저 읽어야 한다. \n\n- 할당문의 오른쪽에서는 객체를 \"생성\"하거나 \"가져옴\"\n- 그 후에 라벨을 붙이듯이 할당문 왼쪽의 변수가 할당문 오른쪽의 객체에 바인딩 된다. (참조)\n\n`-` `b=a`는 \n\n> 나는 이미 a가 의미하는게 무엇인지 알고있어. 그런데 그 실체를 b라고도 부르고 싶어. \n\n라는 것과 같다. 즉 이미 `a`라고 부르고 있는것을 내가 `b`라고도 부르고 싶다는 의미인데 이는 마치 별명과 같다. (`b`는 `a`의 별명, alias) 그리고 이처럼 하나의 오브젝트에 여러개의 이름을 붙이는 것을 에일리어싱이라고 부른다. \n\n# id, value \n\n## 예제1: 같은 value, 다른 id\n\n> 포인트: (1) 포스트잇 개념의 확실한 이해 (2) 할당문을 새로운 시각으로 해석하는 연습 (3) \"생성->할당\"과 \"참조/에일리어싱\"의 구분\n\n여기에서 a,b,c는 모두 같은 value를 가진다. \n\n하지만 그 id까지 같은 것은 아니다. \n\n## 예제2\n\n> 선행지식: \"생성->할당\" 과 \"참조/에일리어싱\"의 구분\n\n> 포인트: 재할당의 이해!!\n\n(관찰)\n\n(해설)\n\n- 포인트: [1,2,3]+[4] 가 실행되는 순간 새로운 오브젝트가 만들어지고 그 오브젝트를 a라는 이름으로 다시 할당되었음. (재할당)\n\n# 인터닝 \n\n## 예제1\n\n> 선행지식: \"생성->할당,재할당\" 과 \"참조/에일리어싱\"의 구분\n\n> 포인트: 인터닝을 위한 떡밥예제\n\n- 당연한결과임. \n\n## 예제2: 이제 다 이해했다고 생각했는데.. \n\n> 선행지식: \"생성->할당,재할당\" 과 \"참조/에일리어싱\"의 구분\n\n> 포인트: 인터닝의 이해\n\n- id(a)와 id(b)가 왜 똑같지..? \n\n(해설) 파이썬의 경우 효율성을 위해서 -5~256까지의 정수를 미리 저장해둠. \n\n- 3은 언제나 7394720에 지박령마냥 밖혀있음 \n\n# `.copy()`의 사용 (shallow copy의 사용)\n\n> 선행지식: \"생성->할당,재할당\" 과 \"참조/에일리어싱\"의 구분\n\n> 포인트: \"생성->할당,재할당\" 과 \"참조/에일리어싱\"의 연습, 복사를 위한 떡밥예제\n\n## 예제1\n\n(관찰) 아래의 예제를 살펴보자. 참조를 제대로 이해했다면 아래의 예제는 자연스럽게 이해가능할 것임. \n\n(해설)\n\n이해는 되지만 우리가 원한건 이런게 아니야 \n\n## 예제2: R과 같이 = 를 쓰고 싶다면? \n\n> 선행지식: \"생성->할당,재할당\" 과 \"참조/에일리어싱\"의 구분\n\n> 포인트: 복사의 사용, 얕은복사의 떡밥\n\n(관찰)\n\n(해설)\n\n## 예제3: 이제 다 이해했다고 생각했는데.. \n\n> 선행지식: \"생성->할당,재할당\" 과 \"참조/에일리어싱\"의 구분, 복사의 사용\n\n> 포인트: 얕은복사를 이해하지 못할때 생기는 개념충돌 \n\n(관찰)\n\n(의문)\n\n- l1이랑 l2의 주소도 다르게 나오는데 왜 또 참조한것마냥 l1과 l2가 같이 바뀌고 있지? \n\n***나는 진정한 복사(=깊은복사)를 하고싶다***\n\n# Shallow copy의 이해\n\n`-` 방금 살펴본 예제3을 이해하기 위해서는 shallow copy를 이해해야 한다. \n\n## 예제1\n\n> 선행지식: 이전까지 모든것 \n\n> 포인트: 0차원 자료형의 메모리 구조 이해, 1차원 자료형의 메모리 구조를 위한 떡밥\n\n(관찰+해설)\n\n메모리 상황 \n\n1. 2222라는 오브젝트가 어떤공간(`139753545300880`)에 생성되고 그 공간에 `a`라는 라벨이 붙음 \n2. 2222라는 오브젝트가 어떤공간(`139753545301808`)에 생성되고 그 공간에 `b`라는 라벨이 붙음 \n\n즉 -5~256 이외의 2개의 메모리 공간을 추가적으로 사용 \n\n## 예제2\n\n> 선행지식: 이전까지 모든것, 0차원 자료형의 메모리저장상태 이해 \n\n> 포인트: (1) 1차원 자료형의 메모리 구조 이해 (2) 가변형객체라는 표현의 의미 \n\n(관찰)\n\n(해설)\n\n메모리상황 \n\n0. -5~256까지의 숫자는 미리 메모리에 저장되어 있다. 이중에서 1은 `7394656`, 2는 `7394688`에 저장되어있음. \n1. 2222가 공간 `139753178093776`에서 만들어진다. \n2. 어떠한 리스트오브젝트가 공간 `139753182327904`에서 만들어지고 원소로 [1,2,2222]를 가진다. 이 공간에 `a`라는 포스트잇을 붙인다. \n3. 2222가 공간 `139753178095568`에서 만들어진다.\n4. 어떠한 리스트오브젝트가 공간 `139753173818656`에서 만들어지고 원소로 [1,2,2222]를 가진다. 이 공간에 `b`라는 포스트잇을 붙인다. \n5. `a`라는 포스트잇이 붙은 공간으로 이동하여 원소에 4를 추가시킨다. \n\n즉 -5~256이외에 4개의 메모리 공간을 추가사용 (a,b,a의 2222,b의 2222)\n\n## 예제3\n\n> 선행지식: 이전까지 모든 것\n\n> 포인트: `l2=l1` 와 `l2=l1.copy()` 의 차이점\n\n(관찰)\n\n(해설)\n\n메모리상황 \n\n0. -5~256까지의 숫자가 메모리에 저장되어 있다. \n1. 저장된 숫자중 66,55,44를 묶어서 리스트로 구성하고 이 리스트를 공간 `139753183707216`에 저장. \n2. 숫자 3과 공간 `139753183707216`에 저장된 리스트 [66,55,44]를 하나로 묶어서 새로운 리스트를 구성하고 이를 공간 `139753183437040`에 저장. 공간 `139753183437040`에 `l1`이라는 포스트잇 생성. \n3. 공간 `139753182311120`에 `l1`의 원소들을 모아서 새로운 리스트를 구성함. 공간 `139753182311120`에 `l2`라는 포스트잇 생성. 그런데 따져보니까 내부구성은 똑같아?\n\n0. l1[0]은 원래 공간 `7394720`와 binding 되어 있었음.  \n1. 그런데 7777이라는 새로운 오브젝트가 공간 `139753178092080`에 생성되고 l1[0]이 공간 `139753178092080`와 다시 binding 됨. \n\n## 예제4\n\n> 선행지식: 이전까지 모든것, `.copy()`의 동작원리 \n\n> 포인트: `.copy()`의 동작원리 재학습\n\n(관찰)\n\n(해설)\n\n## 예제5: 우리를 힘들게 했던 그 예제. \n\n> 선행지식: 이전까지 모든것, `.copy()`의 동작원리 \n\n> 포인트: (1) `.copy()`의 한계, (2) 얕은복사라는 명칭의 유래\n\n(관찰)\n\n(해설-시점1)\n\n(해설-시점2)\n\n해설: 사실 시점1에서 메모리 주소상황을 잘 이해했다면 신기한 일이 아니다. `.copy()`는 l1과 l2의 주소만 다르게 만들 뿐 내용물인 `l1[0]`,`l1[1]`는 동일하니까.\n\n## 예제6: 신임교수=['최규빈','이영미']\n\n> 선행지식: 이전까지의 모든것 \n\n> 포인트: 이전까지의 모든것 점검\n\n`-` 최규빈, 이영미는 신임교수임 \n\n`-` 신임교수를 누군가는 막내들이라고 부르기도 함. \n\n\"막내들\"이라는 단어와 \"신임교수\"라는 단어는 사실 같은 말임 \n\n`-` 새로운 교수 \"박혜원\"이 뽑혔음. \n\n`-` 전북대 통계학과에서 R특강팀을 구성하여 방학중 R교육을 실시하고자함. 특강팀은 우선 신임교수들로 구성. \n\n`-` R특강팀에 `최혜미`교수님 추가. (그렇지만 최혜미교수님이 막내는 아니야.. // 참조와 shallow copy의 차이점) \n\n`-` R특강팀에서 양성준 교수를 추가하여 파이썬 특강팀을 구성 (R특강팀의 구분을 위해서 중첩리스트 구조로 만들자)\n\n`-` 이영미교수는 다른 일이 많아서 R특강 팀에서 제외됨. (그럼 자연히 파이썬에서도 제외됨!!) \n\n하지만 이영미교수는 여전히 신임교수이면서 막내들임 \n\n`-` 새로운 교수로 \"손흥민\"이 임용됨. \n\n`-` 그렇다고 해서 손흥민 교수가 바로 R이나 파이썬 특강팀에 자동소속되는건 아님\n\n# Deep copy\n\n## 예제1: Motivation example\n\n`-` 아래의 상황을 다시 생각해보자.\n\n**이슈:** 이영미교수가 파이썬특강에서 제외되면서 ADSP특강팀에서도 제외되었음. 그런데 사실 이영미교수가 파이썬특강팀에서만 제외되길 원한 것이지 ADSP특강팀에서 제외되길 원한게 아닐수도 있음. \n\n**해결**: Deep copy의 사용\n\n## 예제2\n\n> 선행지식: 이전까지 모든것, 얕은복사 \n\n> 포인트: (1) 깊은복사 (2) 복사의 레벨을 이해 (3) 얕은복사 = 1단계 깊은복사\n\n`-` deepcopy\n\n- 레벨1: `l1`,`l2` 의 메모리 주소가 다름을 확인\n\n- 레벨2: `l1안에 있는 [66,[55,44]]`와 `l2안에 있는 [66,[55,44]]`의 메모리 주소가 다름도 확인. \n\n- 레벨3: `l1안의 [66,[55,44]] 안의 [55,44]`와 `l2안의 [66,[55,44]] 안의 [55,44]`의 메모리 주소까지도 다름을 확인. \n\n`-` 비교를 위한 shallow copy\n\n- 레벨1: `l1`,`l2` 의 메모리 주소가 다름을 확인\n\n- 레벨2: `l1안에 있는 [66,[55,44]]`와 `l2안에 있는 [66,[55,44]]`의 메모리 주소는 같음!!\n\n- 레벨3: `l1안의 [66,[55,44]] 안의 [55,44]`와 `l2안의 [66,[55,44]] 안의 [55,44]`의 메모리 주소도 같음!!\n\n`-` 비교를 위한 참조 \n\n- 레벨1: `l1`,`l2` 여기서부터 메모리 주소가 같다. \n\n> Note: 문헌에 따라서 shallow copy를 level1 deep copy라고 부르기도 한다. \n\n# Shallow copy 연습문제 \n\n## 예제1\n\n> 선행지식: 이전까지 모든것\n\n> 포인트: 얕은복사의 한계점 이해\n\n`-` 아래의 코드결과를 예측하라. 결과가 나오는 이유를 설명하라. \n\n- 포인트: shallow copy (=level 1 deep copy) 이므로 `l1안의 [66,55,44]`와 `l2안의 [66,55,44]`는 같은 메모리 주소를 가짐 \n\n## 예제2\n\n> 선행지식: 이전까지 모든것\n\n> 포인트: 재할당의 활용하여 얕은복사의 한계점 극복\n\n`-` 아래의 코드결과를 예측하라. 결과가 나오는 이유를 설명하라. \n\n- 포인트: `l1[-1]+[33]`가 실행되는 순간 새로운 오브젝트가 생성되고 이 새로운 오브젝트가 l1의 마지막 원소에 새롭게 할당된다. \n\n## 예제3\n\n> 선행지식: 이전까지 모든것\n\n> 포인트: 재할당의 활용하여 얕은복사의 한계점 극복, 예제4를 위한 떡밥\n\n- 포인트: 이 상황에서 `l1안의 [66,55,44]`와 `l2안의 [66,55,44]`는 서로 다른 메모리 주소를 가진다. \n\n## 예제4\n\n> 선행지식: 이전까지 모든것\n\n> 포인트: 재할당으로 인해 메모리주소가 틀어짐을 이용한 트릭예제, 예제5의 떡밥예제\n\n(잘못된 상상) 아래의 코드와 결과가 같을거야!!\n\n(하지만 현실은)\n\n## 예제5\n\n> 선행지식: 이전까지 모든것\n\n> 포인트: `+=`는 재할당이 아니다. \n\n***`+=` 연산자의 올바른 이해***\n\n> ??? 예제4랑 예제5는 같은코드가 아니었음!!! `a += [1]` 는 새로운 오브젝트를 만드는게 아니고, 기존의 오브젝트를 변형하는 스타일의 코드였음! (마치 append 메소드처럼) \n\n# 불변형 객체 \n\n## 예제1: Motivation example\n\n> 선행지식: 이전까지 모든것\n\n> 포인트: `+=`는 재할당이 아니다. \n\n`-` 우리는 이제 아래의 내용은 마스터함 \n\n`-` 아래의 결과를 한번 예측해볼까? \n\n## 해설 \n\n(시점1)\n\n(시점2)\n\n주소 `140006812590400:(66,55,44)`에 있는 값을 바꾸고 싶지만 불변형이라 못바꿈 $\\to$ 그냥 새로 만들자. 그래서 그걸 `140006813422272`에 저장하자. \n\n# Shallow-copy vs Deep-copy\n\n`-` 암기용문구: \"얕은복사는 껍데기만 복사한다. 깊은복사는 내부까지 복사한다.\"\n\n`-` 일부교재에서는 경우에 따라 얕은복사가 선호될 수 있다는 식으로 설명되어있으나 솔직히 대부분 코드에서 얕은복사의 동작을 정확하게 의도하고 코드를 사용하진 않는다. 대부분의 경우에서 얕은복사는 불필요한 side effect을 유발하는 쓸모없는 개념이라 생각한다. (복사를 이미 하려고 마음먹었으면 보통 깊은복사를 생각함, 그게 아니라면 차라리 참조를 썼겠지..)\n\n`-` 그럼 얕은복사의 장점은 무엇인가? 얕은복사가 깊은복사보다 메모리를 더 적게 사용한다. \n\n```Python\n## 예제1\nlst1 = ['양성준',['최규빈','이영미','최혜미']]\nlst2 = lst1.copy()\n## 예제2 \nlst1 = ['양성준',['최규빈','이영미','최혜미']]\nlst2 = copy.deepcopy(lst1)\n```\n\n- 예제1: 4+1+2 = 7개의 공간 사용 \n- 예제2: 4+2+2 = 8개의 공간 사용 \n\n**요약**\n\n`-` 파이썬은 메모리를 아끼기 위해서 얕은복사라는 이상한 행동을 한다. (하지만 우리는 보통 얕은복사를 원하지 않아. 우리는 깊은복사만 쓰고 싶음!) \n\n`-` 통찰1: 그런데 오묘하게도 [1,2,3,4,5,6]와 같이 1차원 리스트인 경우는 문제가 되지 않음. \n\n-  1차원 리스트의 경우(= 중첩된 리스트가 아닐 경우)는 \"레벨1 수준의 깊은복사\"만 있으면 충분하다. 따라서 \"shallow copy = deep copy\" 임.\n\n`-` 통찰2: 생각해보니까 모든 자료형이 불변형인 경우에도 문제가 되지 않음. (R은 모든 자료형이 불변형이다) \n\n`-` 문제상황요약: [[1,2],[3,4]] 와 같이 리스트에 리스트가 포함된 형태라면 문제가 생긴다. $\\to$ 그런데 우리가 자주 쓰는 매트릭스가 사실 이러한 중첩된 리스트 구조 아니야? 이거 문제인데? \n\n- 해결책1: 깊은복사를 하면 된다. (이미했음)\n- 해결책2: 넘파이를 쓰면된다. (이걸로 뭘 어떻게 개선한다는거야?)\n\n# numpy \n\n## 2차원의 실체 \n\n`-` 2차원 array a,b를 선언하자. \n\n`-` a,b,c,d 속성비교 \n\n`-` ((16, 8), (24, 8), (8, 8), (8,)) 와 같은 저 숫자들이 도데체 무엇을 의미하는거야?!\n\n- 사전지식: 컴퓨터는 하나의 숫자를 저장하는데 메모리를 8칸 쓴다. \n- 가정: 만약에 컴퓨터가 1차원으로만 숫자를 저장한다면?? \n- strides의 의미: (다음 행으로 가기위해서 JUMP해야하는 메모리 공간수, 다음 열로 가기위해서 JUMP해야하는 메모리 공간수) \n\n`-` 통찰: strides의 존재로 인해서 유추할 수 있는 것은 a,b,c,d 는 모두 1차원으로 저장되어있다는 사실이다. (중첩된 리스트꼴이 아니라)\n\n`-` 그렇다면.. shallow copy = deep copy?!\n\n`-` 해방: 넘파이를 쓰면 `copy.deepcopy()`를 쓰지 않아도 된다. \n\n`-` 용어정리: (필요할까..?)\n\n- numpy 한정 `.copy()` 는 copy모듈의 deep copy와 동등한 효과를 준다. 하지만 실제로는 shallow copy 이다. [공식문서](https://numpy.org/doc/stable/reference/generated/numpy.copy.html)에는 \"Note that np.copy is a shallow copy and will not copy object elements within arrays.\" 라고 명시되어 있음. \n- 일부 블로그에서 deep copy라고 주장하기도 함. [블로그1](https://humaneer.net/292), [블로그2](https://python.plainenglish.io/shallow-copy-and-deep-copy-in-python-numpy-8861e0870c5f), [블로그3](https://yeko90.tistory.com/entry/%EB%84%98%ED%8C%8C%EC%9D%B4-%EA%B8%B0%EC%B4%88-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC-copy-view) // 블로그2의 경우 참조와 shallow copy도 구분못함.. \n- 이따가 view라는 개념도 나올텐데 `.copy()`를 deep copy라고 주장하는 블로거들 대부분 `.view()`를 shallow copy 혹은 참조라고 주장한다. 하지만 copy와 view를 설명하는 [공식문서](https://numpy.org/doc/stable/user/basics.copies.html)에서는 view가 shallow copy라는 말을 찾아볼 수 없음. \n\n`-` 정리 (넘파이한정)\n\n- `nparray.copy()`: 실제로는 shallow copy, 그런데 느낌은 deep copy \n- `nparray.view()`: 실제로는 shallow copy 보다 더 얕은 단계의 카피, 그런데 느낌은 shallow copy\n\n## 참조 \n\n`-` a를 선언, b는 a의 참조\n\n`-` a의 shape을 바꾸어보자 $\\to$ b도 같이 바뀐다 \n\n## view \n\n`-` a를 선언, b는 a의 view\n\n`-` 그런데.. \n\n`-` 출생의 비밀 \n\n- ? 이거 바뀐 a아니야? \n\n`-` View \n\n- b가 a의 뷰라는 의미는, b가 a를 소스로하여 만들어진 오브젝트란 의미이다. \n- 따라서 이때 b.base는 a가 된다. \n- b는 자체적으로 데이터를 가지고 있지 않으며 a와 공유한다. \n\n`note1` 원본 ndarray의 일 경우는 .base가 None으로 나온다. \n\n`note2` b.base의 shpae과 b의 shape은 아무 관련없다. \n\n`-` numpy에서 view를 사용하는 예시 (transpose)\n\n- `X.T` 는 `X`의 view 이다.\n\n## copy \n\n`-` a를 선언, b는 a의 copy\n\n`-` a의 shape을 바꿔도 b에는 적용되지 않음 \n\n`-` 그리고 a[0]의 값을 바꿔도 b에는 적용되지 않음. \n\n`-` b의 출생을 조사해보니.. \n\n출생의 비밀은 없었다. 둘다 원본. \n\n`-` `.view()` 는 껍데기만 새로생성 //  `.copy()` 는 껍데기와 데이터를 모두 새로 생성 \n\n### ***Appendix: .copy의 한계(?)***\n\n(관찰)\n\n- 왜 또 시점2에서는 a와 b가 같이 움직여?\n\n***해결책: 더 깊은 복사***\n\n`-` 중간요약\n\n- 사실 `b=a.copy()`는 에서 `.copy()`는 사실 온전한 deep-copy가 아니다. \n- 그래서 `a`의 데이터가 중첩구조를 가지는 경우는 온전한 deep-copy가 수행되지 않는다. \n- 그런데 일반적으로 넘파이를 이용할때 자주 사용하는 데이터 구조인 행렬, 텐서등은 데이터가 중첩구조를 가지지 않는다. (1차원 array로만 저장되어 있음) \n- 따라서 행렬, 텐서에 한정하면 `.copy()`는 온전한 deep-copy라고 이해해도 무방하다. <-- 이것만 기억해!\n\n## 요약 \n\n아래를 구분할 수 있으면 잘 이해한 것!! \n\n```Python \narr = np.array(...) # arr -- [arr.shape, arr.strides, arr.base, ... ] \narr2 = arr \narr2 = arr.view()\narr2 = arr.copy()\narr2 = copy.deepcopy(arr)\n```\n\n## 별명, 뷰, 카피 \n\n`-` test 함수 작성 \n\n`-` 잘 동작하나? \n\n(테스트1) \n\n(테스트2) \n\n(테스트3) \n\n(테스트4) \n\n## 결론 \n\n`-` 참조, 뷰, 카피의 개념을 잘 알고 있고 때에 따라 메모리를 아끼면서 이들을 적절하게 사용하고 싶을것 같음. 하지만 이건 불가능한 소망임. \n\n`-` 우리가 사용했던 어떠한 것들이 뷰가 나올지 카피가 나올지 잘 모른다. (그래서 원리를 이해해도 대응할 방법이 사실없음) \n\n### 예시1\n\n### 예시2\n\n`-` 심지어 copy인줄 알았던것이 사실 view라서 원치않는 side effect이 생길수 있음. $\\to$ 그냥 방어적 프로그래밍이 최선인듯 \n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"2023-06-21-13wk-1.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.315","theme":"cosmo","code-copy":true,"title-block-banner":true,"title":"13wk-1: 깊은복사와 얕은복사","author":"최규빈","date":"06/21/2023"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}