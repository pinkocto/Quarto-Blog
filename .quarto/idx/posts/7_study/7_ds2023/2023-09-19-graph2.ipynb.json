{"title":"3wk-1 그래프2","markdown":{"yaml":{"title":"3wk-1 그래프2","author":"JiyunLim","date":"09/19/2023"},"headingText":"Tools-matplotlib","containsRefs":false,"markdown":"\n\n\n 데이터 몇 개로 plot 함수를 호출한 다음, show 함수를 호출해주면 간단히 그래프를 그려볼 수 있습니다!\n\nplot 함수에 단일 배열의 데이터가 주어진다면, 수직 축의 좌표로서 이를 사용하게 되며, 각 데이터의 배열상 색인(인덱스)을 수평 좌표로서 사용합니다. 두 개의 배열을 넣어줄 수도 있습니다: 그러면, 하나는 x 축에 대한것이며, 다른 하나는 y 축에 대한것이 됩니다:\n\n`-`  object oriented API를 이용하여 그려보자.\n\n- 지금까지는 뭘할지만 썼다면, object oriented를 이용하면 이 함수를 \"누가\" 실행해야하는지 앞에 **누가** 가 들어간다.^[여기서 \"누가\"가 object // 즉, object에 뭘할지 시킨다.]\n\n* `pyplot`과 동일한 형태의 그래프가 그려집니다.   \n* `fig`, `ax`를 선언하느라 한 줄을 더 입력해야 한다는 불편함이 있지만 `ax` 객체가 있어 그래프를 제어하기 더 쉬워집니다.\n* 많은 경우 `fig, ax = plt.subplots()` 대신 `ax = plt.subplot()`으로 해도 됩니다.\n* 그러나 fig 대상 명령(예. savefig)을 사용해야 할 때도 있고, 두 가지를 따로 외우려면 혼동이 되니 한 가지로 통일하는 것이 좋습니다.\n\n이번에는 수학적인 함수를 그려보겠습니다. NumPy의 linespace 함수를 사용하여 -2 ~ 2 범위에 속하는 500개의 부동소수로 구성된 x 배열을 생성합니다. 그 다음 x의 각 값의 거듭제곱된 값을 포함하는 y 배열을 생성합니다 (NumPy에 대하여 좀 더 알고 싶다면, [NumPy 튜토리얼](https://colab.research.google.com/drive/tools_numpy.ipynb)을 참고하시기 바랍니다).\n\n그래프가 약간은 삭막해 보입니다. 타이틀과 x 및 y축에 대한 라벨, 그리고 모눈자를 추가적으로 그려보겠습니다.\n\n* object-oriented API는 축 이름과 같은 설정 명령어가 `pyplot`과 다소 다릅니다.  \n* 대체로 축 이름(label), 범위(limits) 등을 지정하는 명령어는 `set_대상()`, 거꾸로 그래프에서 설정값을 가져오는 명령어는 `get_대상()`으로 통일되어 있습니다.  \n* 개인적으로 `pyplot`의 명령어 체계보다 `object-oriented API`의 체계를 선호합니다.\n\n## 한글오류\n\n\n\n::: {.callout-tip}\n## 그래프 title에 수식쓰는 법\n\n따옴표 내부에 달러기호 안에 수식을 쓰면 된다.\n:::\n\n## 선의 스타일과 색상\n\n세번째 파라미터를 지정하면 선의 스타일과 색상을 바꿀 수 있습니다. 예를들어 \"g--\"는 \"초록색 파선\"을 의미합니다.\n\n또는 show를 호출하기 전 plot을 여러번 호출해도 가능합니다.\n\n또는 show를 호출하기 전 plot을 여러번 호출해도 가능합니다.\n\n선 대신에 간단한 점을 그려보는 것도 가능합니다. 아래는 초록색 파선, 빨강 점선, 파랑 삼각형의 예를 보여줍니다. [공식 문서](https://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.plot)에서 사용 가능한 스타일 및 색상의 모든 옵션을 확인해 볼 수 있습니다.\n\nplot 함수는 Line2D객체로 구성된 리스트를 반환합니다 (각 객체가 각 선에 대응됩니다). 이 선들에 대한 추가적인 속성을 설정할 수도 있습니다. 가령 선의 두께, 스타일, 투명도 같은것의 설정이 가능합니다. [공식 문서](https://matplotlib.org/tutorials/introductory/pyplot.html)에서 설정 가능한 모든 속성을 확인해볼 수 있습니다.\n\n## 그림 저장\n\n그래프를 그림파일로 저장하는 방법은 간단합니다. 단순히 파일이름을 지정하여 [savefig](https://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.savefig) 함수를 호출해 주기만 하면 됩니다. 가능한 이미지 포맷은 사용하는 그래픽 백엔드에 따라서 지원 여부가 결정됩니다.\n\n## 부분 그래프 (subplot)\n\nmatplotlib는 하나의 그림(figure)에 여러개의 부분 그래프를 포함할 수 있습니다. 이 부분 그래프는 격자 형식으로 관리됩니다. `subplot` 함수를 호출하여 부분 그래프를 생성할 수 있습니다. 이 때 격자의 행/열의 수 및 그래프를 그리고자 하는 부분 그래프의 색인을 파라미터로서 지정해줄 수 있습니다 (색인은 1부터 시작하며, 좌->우, 상단->하단의 방향입니다).\n* `pyplot`은 현재 활성화된 부분 그래프를 계속해서 추적합니다 (`plt.gca()`를 호출하여 해당 부분 그래프의 참조를 얻을 수 있습니다). 따라서, `plot` 함수를 호출할 때 활성화된 부분 그래프에 그림이 그려지게 됩니다.\n\n> 이제현 주 :  \n* `object oriented API` 방식에서는 그래프를 그리기 전에 먼저 틀을 잡아둡니다. 그래프를 그릴 때 사전에 정의된 영역 중 어디에 그래프를 그릴지 지정하는 방식입니다.  \n* `pyplot`의 `plt.gca()`가 바로 object oriented API의 `axes`입니다.\n\n격자의 여러 영역으로 확장된 부분 그래프를 생성하는 것도 쉽습니다.\n\n보다 복잡한 부분 그래프의 위치 선정이 필요하다면, `subplot2grid`를 대신 사용할 수 있습니다. 격자의 행과 열의 번호 및 격자에서 해당 부분 그래프를 그릴 위치를 지정해줄 수 있습니다 (좌측상단 = (0,0). 또한 몇 개의 행/열로 확장되어야 하는지도 추가적으로 지정할 수 있습니다. 아래는 그에 대한 예를 보여줍니다:\n\n보다 유연한 부분그래프 위치선정이 필요하다면, [GridSpec 문서](https://matplotlib.org/users/gridspec.html)를 확인해 보시길 바랍니다.\n\n## 여러개의 그림 (figure)\n\n여러개의 그림을 그리는것도 가능합니다. 각 그림은 하나 이상의 부분 그래프를 가질 수 있습니다. 기본적으로는 matplotlib이 자동으로 figure(1)을 생성합니다. 그림간 전환을 할 때, pyplot은 현재 활성화된 그림을 계속해서 추적합니다 (이에대한 참조는 `plt.gcf()`의 호출로 알 수 있습니다). 또한 활성화된 그림의 활성화된 부분 그래프가 현재 그래프가 그려질 부분 그래프가 됩니다.\n\n> 이제현 주 :\n* `object oriented API`에서는 실행 순이 아니라 객체를 중심으로 명령을 실행합니다.\n* 다른 그림을 그리다가 앞서 그림을 추가할 때 `pyplot`에서 `plt.figure()` 명령으로 위 그림을 호출하는 대신 `object oriented API`는 목표 `Axes`를 지정하여 추가합니다.\n\n\n## Pyplot의 상태 머신: 암시적 vs 명시적\n\n지금까지 현재의 활성화된 부분 그래프를 추적하는 Pyplot의 상태 머신을 사용했었습니다. `plot` 함수를 호출할 때마다 pyplot은 단지 현재 활성화된 부분 그래프에 그림을 그립니다. 그리고 `plot` 함수를 호출 할 때, 그림 및 부분 그래프가 아직 존재하지 않는다면 이들을 만들어내는 마법같은(?) 작업도 일부 수행합니다. 이는 주피터와 같은 대화식의 환경에서 편리합니다.\n\n그러나 프로그램을 작성하는 것이라면, 명시적인 것이 암시적인것 보다 더 낫습니다. 명시적인 코드는 일반적으로 디버깅과 유지보수가 더 쉽습니다. 이 말에 동의하지 않는다면, Python 젠(Zen)의 두 번째 규칙을 읽어보시기 바랍니다.\n\n아름다움이 추한 것보다 낫다.\n\n명확함이 함축된 것보다 낫다.\n\n단순함이 복잡한 것보다 낫다.\n\n복잡함이 난해한 것보다 낫다.\n\n단조로움이 중접된 것보다 낫다.\n\n여유로움이 밀집된 것보다 낫다.\n\n가독성은 중요하다.\n\n비록 실용성이 이상을 능가한다 하더라도 규칙을 깨야할 정도로 특별한 경우란 없다.\n\n알고도 침묵하지 않는 한 오류는 결코 조용히 지나가지 않는다.\n\n모호함을 마주하고 추측하려는 유혹을 거절하라. 비록 당신이 우둔해서 처음에는 명백해 보이지 않을 수도 있겠지만 문제를 해결할 하나의 - 바람직하고 유일한 - 명백한 방법이 있을 것이다.\n\n비록 하지않는 것이 지금 하는 것보다 나을 때도 있지만 지금 하는 것이 전혀 안하는 것보다 낫다.\n\n설명하기 어려운 구현이라면 좋은 아이디어가 아니다. 쉽게 설명할 수 있는 구현이라면 좋은 아이디어일 수 있다. 네임스페이스는 정말 대단한 아이디어다. -- 자주 사용하자!\n\nfrom [출처](https://wikidocs.net/7907)\n\n다행히도 Pyplot은 상태 머신을 완전히 무시할 수 있게끔 해 줍니다. 따라서 아름다운 명시적 코드를 작성하는것이 가능하죠. 간단히 `subplots` 함수를 호출해서 반환되는 figure 객체 및 축의 리스트를 사용하면 됩니다*. 마법은 더 이상 없습니다!\n\n> 이제현 주:\n* 여기서 설명하는 부분이 `matplotlib`의 `object oriented API`(객체지향 인터페이스)입니다.\n\n아래는 이에 대한 예 입니다:\n\n일관성을 위해서 이 튜토리얼의 나머지 부분에서는 pyplot의 상태 머신을 계속해서 사용할 것입니다. 그러나 프로그램에서는 객체지향 인터페이스의 사용을 권장하고 싶습니다.\n\n## Pylab *vs* Pyplot *vs* Matplotlib\n\npylab, pyplot, matplotlib 간의 관계에대한 혼동이 있습니다. 그러나 이들의 관계는 매우 단순합니다: matplotlib은 완전한 라이브러리이며, pylab 및 pyplot을 포함한 모든것을 가지고 있습니다.\n\nPyplot은 그래프를 그리기위한 다양한 도구를 제공합니다. 여기에는 내부적인 객체지향적인 그래프 그리기 라이브러리에 대한 상태 머신 인터페이스도 포함됩니다.\n\nPylab은 mkatplotlib.pyplot 및 NumPy를 단일 네임스페이스로 임포트하는 편리성을 위한 모듈입니다. 인터넷에 떠도는 pylab을 사용하는 여러 예제를 보게 될 것입니다. 그러나 이는 더이상 권장되는 사용방법은 아닙니다 (왜냐하면 *명시적*인 임포트가 *암시적인*것 보다 더 낫기 때문입니다).\n\n> 이제현 주 :\n* Pylab, Pyplot, Object oriented API의 관계는 [여기](https://matplotlib.org/3.2.1/api/index.html)를 참고하십시오\n\n## 텍스트 그리기\n`text` 함수를 호출하여 텍스트를 그래프의 원하는 위치에 추가할 수 있습니다. 출력을 원하는 텍스트와 수평 및 수직 좌표를 지정하고, 추가적으로 몇 가지 속성을 지정해 주기만 하면 됩니다. matplotlib의 모든 텍스트는 TeX 방정식 표현을 포함할 수 있습니다. 더 자세한 내용은 [공식 문서](http://matplotlib.org/users/mathtext.html)를 참조하시기 바랍니다.\n\n* 알아둘 것: `ha`는 `horizontalalignment(수평정렬)`의 이명 입니다.\n\n더 많은 텍스트 속성을 알고 싶다면, [공식 문서](http://matplotlib.org/users/text_props.html#text-properties)를 참조하시기 바랍니다.\n\n아래 그래프의 \"beautiful point\" 같은 텍스트 처럼, 그래프의 요소에 주석을 다는것은 꽤 흔한 일입니다. `annotate` 함수는 이를 쉽게 할 수 있게 해 줍니다: 관심있는 부분의 위치를 지정하고, 텍스트의 위치를 지정합니다. 그리고 텍스트 및 화살표에 대한 추가적인 속성도 지정해줄 수 있습니다.\n\n`bbox` 속성을 사용하면, 텍스트를 포함하는 사각형을 그려볼 수도 있습니다:\n\n재미를 위해서 [xkcd](http://xkcd.com) 스타일의 그래프를 그려보고 싶다면, `with plt.xkcd()` 섹션 블록을 활용할 수도 있습니다:\n\n## 범례 (Legends)\n\n범례를 추가하는 가장 간단한 방법은 모든 선에 라벨을 설정해주고, `legend` 함수를 호출하는 것입니다.\n\n## 비선형 척도\n\nMatplotlib은 로그, 로짓(logit)과 같은 비선형 척도를 지원합니다.\n\n## 틱과 틱커 (Ticks and tickers)\n\n각 축에는 \"틱(ticks)\"이라는 작은 표시가 있습니다. 정확히 말하자면, \"틱\"은 표시(예. (-1, 0, 1))의 *위치*\"이며, *틱 선*은 그 위치에 그려지는 작은 선입니다. 또한 \"틱 라벨\"은 틱 선 옆에 그려지는 라벨이며, \"틱커\"는 틱의 위치를 결정하는 객체 입니다. 기본적인 틱커는 ~5 에서 8 틱을 위치시키는데 꽤 잘 작동합니다. 즉, 틱 서로간에 적당한 거리를 표현합니다.\n\n하지만, 가끔은 좀 더 이를 제어할 필요가 있습니다 (예. 위의 로짓 그래프에서는 너무 많은 틱 라벨이 있습니다). 다행히도 matplotlib은 틱을 완전히 제어하는 방법을 제공합니다. 심지어 보조 눈금(minor tick)을 활성화 할 수도 있습니다.\n\n\n## 극좌표계의 투영 (Polar projection)\n\n극좌표계 그래프를 그리는 것은 매우 간단합니다. 부분 그래프를 생성할 때 `projection` 속성을 `\"polar\"`로 설정해 주기만 하면 됩니다.\n\n> 이제현 주:   \n* `object oriented API`는 일반적으로 `plt.subplots()`로 `Figure`와 `Axes` 객체를 동시에 생성합니다.\n* `plt.subplots()`는 `projection` 속성을 가지고 있지 않습니다.\n* 따라서 `projection`을 사용할 때는 `plt.figure()`로 `Figure` 객체를 먼저 생성한 후 `plt.subplot()`이나 `plt.add_subplot()`으로 `Axes` 객체를 추가해 주거나,\n  `fig.subplots()` 안에 `subplot_kw=={'polar':True}`로 지정해 주어야 합니다.\n\n## 3차원 투영\n\n3차원 그래프를 그리는것은 꽤 간단합니다. 우선 `\"3d\"` 투영을 등록하는 `Axes3D`를 임포트 해줘야 합니다. 그리곤 `projection` 속성을 `\"3d\"`로 설정된 부분 그래프 생성합니다. 그러면 `Axes3DSubplot` 이라는 객체가 반환되는데, 이 객체의 `plot_surface` 메서드를 호출하면 x, y, z 좌표를 포함한 추가적이나 속성을 지정할 수 있습니다.\n\n동일한 데이터를 출력하는 또 다른 방법은 등고선도(contour plot)를 *이용*하는 것입니다.\n\n## 산점도 (Scatter plot)\n\n단순히 각 점에 대한 x 및 y 좌표를 제공하면 산점도를 그릴 수 있습니다.\n\n부수적으로 각 점의 크기를 정할 수도 있습니다.\n\n마찬가지로 여러 속성을 설정할 수 있습니다. 가령 테두리 및 모양의 내부 색상, 그리고 투명도와 같은것의 설정이 가능합니다.\n\n## 선\n\n지금까지 해온것 처럼 `plot` 함수를 사용하여 선을 그릴 수 있습니다. 하지만, 가끔은 그래프를 통과하는 무한한 선을 그리는 유틸리티 함수를 만들면 편리합니다 (기울기와 절편으로). 또한 `hlines` 및 `vlines` 함수를 사용하면, 아래와 같이 부분 수평 및 수직 선을 그릴 수도 있습니다:\n\n## 히스토그램\n\n## 이미지\n\nmatplotlib에서의 이미지 불러오기, 생성하기, 화면에 그리기는 꽤 간단합니다.\n\n이미지를 불러오려면 `matplotlib.image` 모듈을 임포트하고, 파일이름을 지정한 `imread` 함수를 호출해 주면 됩니다. 그러면 이미지 데이터가 NumPy의 배열로서 반환됩니다. 앞서 저장했던 `my_square_function.png` 이미지에 대하여 이를 수행해 보겠습니다.\n\n> 이제현 주 :\n* 이미지 단독 출력은 `pyplot`과 `object oriented API` 사이에 별 차이가 없습니다.\n* `Axes`를 지정해서 출력하는 것이 다를 뿐입니다.\n* `pyplot`과의 중복성이 강하지만 익숙해지는 차원에서 `object oriented API`를 함께 도시합니다.\n\n\n288x432 크기의 이미지를 불러왔습니다. 각 픽셀은 0~1 사이의 32비트 부동소수 값인 4개의 요소(빨강, 초록, 파랑, 투명도)로 구성된 배열로 표현됩니다. 이번에는 `imshow`함수를 호출해 보겠습니다:\n\n허허허... 이미지 출력에 포함된 축을 숨기고 싶다면 아래와 같이 축을 off 시켜줄 수 있습니다:\n\n여러분만의 이미지를 생성하는것도 마찬가지로 간단합니다:\n\nRGB 수준을 제공하지 않는다면, `imshow` 함수는 자동으로 값을 색그래디언트에 매핑합니다. 기본적인 동작에서의 색그래디언트는 파랑(낮은 값) 에서 빨강(높은 값)으로 움직입니다. 하지만 아래와 같이 다른 색상맵을 선택할 수도 있습니다:\n\nRGB 이미지를 직접적으로 생성하는것 또한 가능합니다:\n\n`img` 배열이 매우 작기 때문에 (20x30), `imshow` 함수는 이미지를 figure 크기에 맞도록 늘려버린채 출력합니다. 이러한 늘리기의 기본 동작은 [쌍선형 보간법(bilinear interpolation)](https://en.wikipedia.org/wiki/Bilinear_interpolation)을 사용하여 추가된 픽셀을 매꿉니다. 테두리가 흐릿한 이유입니다.\n\n다른 보간법 알고리즘을 선택할 수도 있습니다. 가령 아래와 같이 근접 픽셀을 복사하는 방법이 있습니다:\n\n> 이제현 주 :\n* 위 코드의 `ax.imshow(img, interpolation='bilinear')` 부분은 원문에서 `ax.imshow(img)`로 되어 있습니다.\n* `matplotlib` 2.0 이전에는 `interpolation='bilinear'`가 기본값이기 때문에 경계선이 흐려지는 문제가 있었습니다.\n* 그러나 이후 `interpolation='nearest'`로 기본값이 변경되어 흐려지는 문제가 더 이상 발생하지 않습니다.\n* 자세한 사항은 [이 글](https://matplotlib.org/3.2.1/users/prev_whats_new/whats_new_2.0.0.html)을 참고하십시오.\n\n## 애니메이션\n\nmatplotlib은 이미지 생성에 주로 사용되지만, 애니메이션의 출력도 가능합니다. 우선 `matplotlib.animation`을 임포트 해 줘야 합니다. 그 다음은 (주피터 노트북에서) `nbagg`를 백엔드로 설정하거나, 아래의 코드를 실행해 주면 됩니다.\n\n다음의 예는 데이터를 생성하는것으로 시작됩니다. 그 다음, 빈 그래프를 생성하고, 애니메이션을 그릴 매 프레임 마다 호출될 갱신(update) 함수를 정의합니다. 마지막으로, `FuncAnimation` 인스턴스를 생성하여 그래프에 애니메이션을 추가합니다.\n\n`FuncAnimation` 생성자는 figure, 갱신 함수, 그 외의 파라미터를 수용합니다. 각 프레임간 20ms의 시간차가 있는 100개의 프레임으로 구성된 애니메이션에 대한 인스턴스를 만들었습니다. 애니메이션의 각 프레임마다 `FuncAnimation` 는 갱신 함수를 호출하고, 프레임 번호를 `num` (이 예에서는 0~99의 범위) 으로서 전달해 줍니다. 또한 갱신 함수의 추가적인 두 파라미터는 FuncAnimation 생성시 `fargs`에 넣어준 값이 됩니다.\n\n작성한 갱신 함수는 선을 구성하는 데이터를 0 ~ `num` 데이터로 설정합니다 (따라서 데이터가 점진적으로 그려집니다). 그리고 약간의 재미 요소를 위해서, 각 데이터에 약간의 무작위 수를 추가하여 선이 씰룩씰룩 움직이게끔 해 주었습니다.\n\n## 애니메이션을 비디오로 저장\n비디오로 저장하기 위해서 Matplotlib은 써드파티 라이브러리([FFMPEG](https://www.ffmpeg.org/) 또는 [ImageMagick](https://imagemagick.org/)에 의존합니다. 다음의 예는 FFMPEG를 사용하기 때문에, 이 라이브러리가 먼저 설치되어 있어야만 합니다. 애니메이션을 GIF로 저장하고 싶다면 ImageMagick이 필요할 것입니다.\n\n##  MCS로 파이 구하기\n\nref: <https://clauswilke.com/dataviz/>\n","srcMarkdownNoYaml":"\n\n## Tools-matplotlib\n\n 데이터 몇 개로 plot 함수를 호출한 다음, show 함수를 호출해주면 간단히 그래프를 그려볼 수 있습니다!\n\nplot 함수에 단일 배열의 데이터가 주어진다면, 수직 축의 좌표로서 이를 사용하게 되며, 각 데이터의 배열상 색인(인덱스)을 수평 좌표로서 사용합니다. 두 개의 배열을 넣어줄 수도 있습니다: 그러면, 하나는 x 축에 대한것이며, 다른 하나는 y 축에 대한것이 됩니다:\n\n`-`  object oriented API를 이용하여 그려보자.\n\n- 지금까지는 뭘할지만 썼다면, object oriented를 이용하면 이 함수를 \"누가\" 실행해야하는지 앞에 **누가** 가 들어간다.^[여기서 \"누가\"가 object // 즉, object에 뭘할지 시킨다.]\n\n* `pyplot`과 동일한 형태의 그래프가 그려집니다.   \n* `fig`, `ax`를 선언하느라 한 줄을 더 입력해야 한다는 불편함이 있지만 `ax` 객체가 있어 그래프를 제어하기 더 쉬워집니다.\n* 많은 경우 `fig, ax = plt.subplots()` 대신 `ax = plt.subplot()`으로 해도 됩니다.\n* 그러나 fig 대상 명령(예. savefig)을 사용해야 할 때도 있고, 두 가지를 따로 외우려면 혼동이 되니 한 가지로 통일하는 것이 좋습니다.\n\n이번에는 수학적인 함수를 그려보겠습니다. NumPy의 linespace 함수를 사용하여 -2 ~ 2 범위에 속하는 500개의 부동소수로 구성된 x 배열을 생성합니다. 그 다음 x의 각 값의 거듭제곱된 값을 포함하는 y 배열을 생성합니다 (NumPy에 대하여 좀 더 알고 싶다면, [NumPy 튜토리얼](https://colab.research.google.com/drive/tools_numpy.ipynb)을 참고하시기 바랍니다).\n\n그래프가 약간은 삭막해 보입니다. 타이틀과 x 및 y축에 대한 라벨, 그리고 모눈자를 추가적으로 그려보겠습니다.\n\n* object-oriented API는 축 이름과 같은 설정 명령어가 `pyplot`과 다소 다릅니다.  \n* 대체로 축 이름(label), 범위(limits) 등을 지정하는 명령어는 `set_대상()`, 거꾸로 그래프에서 설정값을 가져오는 명령어는 `get_대상()`으로 통일되어 있습니다.  \n* 개인적으로 `pyplot`의 명령어 체계보다 `object-oriented API`의 체계를 선호합니다.\n\n## 한글오류\n\n\n\n::: {.callout-tip}\n## 그래프 title에 수식쓰는 법\n\n따옴표 내부에 달러기호 안에 수식을 쓰면 된다.\n:::\n\n## 선의 스타일과 색상\n\n세번째 파라미터를 지정하면 선의 스타일과 색상을 바꿀 수 있습니다. 예를들어 \"g--\"는 \"초록색 파선\"을 의미합니다.\n\n또는 show를 호출하기 전 plot을 여러번 호출해도 가능합니다.\n\n또는 show를 호출하기 전 plot을 여러번 호출해도 가능합니다.\n\n선 대신에 간단한 점을 그려보는 것도 가능합니다. 아래는 초록색 파선, 빨강 점선, 파랑 삼각형의 예를 보여줍니다. [공식 문서](https://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.plot)에서 사용 가능한 스타일 및 색상의 모든 옵션을 확인해 볼 수 있습니다.\n\nplot 함수는 Line2D객체로 구성된 리스트를 반환합니다 (각 객체가 각 선에 대응됩니다). 이 선들에 대한 추가적인 속성을 설정할 수도 있습니다. 가령 선의 두께, 스타일, 투명도 같은것의 설정이 가능합니다. [공식 문서](https://matplotlib.org/tutorials/introductory/pyplot.html)에서 설정 가능한 모든 속성을 확인해볼 수 있습니다.\n\n## 그림 저장\n\n그래프를 그림파일로 저장하는 방법은 간단합니다. 단순히 파일이름을 지정하여 [savefig](https://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.savefig) 함수를 호출해 주기만 하면 됩니다. 가능한 이미지 포맷은 사용하는 그래픽 백엔드에 따라서 지원 여부가 결정됩니다.\n\n## 부분 그래프 (subplot)\n\nmatplotlib는 하나의 그림(figure)에 여러개의 부분 그래프를 포함할 수 있습니다. 이 부분 그래프는 격자 형식으로 관리됩니다. `subplot` 함수를 호출하여 부분 그래프를 생성할 수 있습니다. 이 때 격자의 행/열의 수 및 그래프를 그리고자 하는 부분 그래프의 색인을 파라미터로서 지정해줄 수 있습니다 (색인은 1부터 시작하며, 좌->우, 상단->하단의 방향입니다).\n* `pyplot`은 현재 활성화된 부분 그래프를 계속해서 추적합니다 (`plt.gca()`를 호출하여 해당 부분 그래프의 참조를 얻을 수 있습니다). 따라서, `plot` 함수를 호출할 때 활성화된 부분 그래프에 그림이 그려지게 됩니다.\n\n> 이제현 주 :  \n* `object oriented API` 방식에서는 그래프를 그리기 전에 먼저 틀을 잡아둡니다. 그래프를 그릴 때 사전에 정의된 영역 중 어디에 그래프를 그릴지 지정하는 방식입니다.  \n* `pyplot`의 `plt.gca()`가 바로 object oriented API의 `axes`입니다.\n\n격자의 여러 영역으로 확장된 부분 그래프를 생성하는 것도 쉽습니다.\n\n보다 복잡한 부분 그래프의 위치 선정이 필요하다면, `subplot2grid`를 대신 사용할 수 있습니다. 격자의 행과 열의 번호 및 격자에서 해당 부분 그래프를 그릴 위치를 지정해줄 수 있습니다 (좌측상단 = (0,0). 또한 몇 개의 행/열로 확장되어야 하는지도 추가적으로 지정할 수 있습니다. 아래는 그에 대한 예를 보여줍니다:\n\n보다 유연한 부분그래프 위치선정이 필요하다면, [GridSpec 문서](https://matplotlib.org/users/gridspec.html)를 확인해 보시길 바랍니다.\n\n## 여러개의 그림 (figure)\n\n여러개의 그림을 그리는것도 가능합니다. 각 그림은 하나 이상의 부분 그래프를 가질 수 있습니다. 기본적으로는 matplotlib이 자동으로 figure(1)을 생성합니다. 그림간 전환을 할 때, pyplot은 현재 활성화된 그림을 계속해서 추적합니다 (이에대한 참조는 `plt.gcf()`의 호출로 알 수 있습니다). 또한 활성화된 그림의 활성화된 부분 그래프가 현재 그래프가 그려질 부분 그래프가 됩니다.\n\n> 이제현 주 :\n* `object oriented API`에서는 실행 순이 아니라 객체를 중심으로 명령을 실행합니다.\n* 다른 그림을 그리다가 앞서 그림을 추가할 때 `pyplot`에서 `plt.figure()` 명령으로 위 그림을 호출하는 대신 `object oriented API`는 목표 `Axes`를 지정하여 추가합니다.\n\n\n## Pyplot의 상태 머신: 암시적 vs 명시적\n\n지금까지 현재의 활성화된 부분 그래프를 추적하는 Pyplot의 상태 머신을 사용했었습니다. `plot` 함수를 호출할 때마다 pyplot은 단지 현재 활성화된 부분 그래프에 그림을 그립니다. 그리고 `plot` 함수를 호출 할 때, 그림 및 부분 그래프가 아직 존재하지 않는다면 이들을 만들어내는 마법같은(?) 작업도 일부 수행합니다. 이는 주피터와 같은 대화식의 환경에서 편리합니다.\n\n그러나 프로그램을 작성하는 것이라면, 명시적인 것이 암시적인것 보다 더 낫습니다. 명시적인 코드는 일반적으로 디버깅과 유지보수가 더 쉽습니다. 이 말에 동의하지 않는다면, Python 젠(Zen)의 두 번째 규칙을 읽어보시기 바랍니다.\n\n아름다움이 추한 것보다 낫다.\n\n명확함이 함축된 것보다 낫다.\n\n단순함이 복잡한 것보다 낫다.\n\n복잡함이 난해한 것보다 낫다.\n\n단조로움이 중접된 것보다 낫다.\n\n여유로움이 밀집된 것보다 낫다.\n\n가독성은 중요하다.\n\n비록 실용성이 이상을 능가한다 하더라도 규칙을 깨야할 정도로 특별한 경우란 없다.\n\n알고도 침묵하지 않는 한 오류는 결코 조용히 지나가지 않는다.\n\n모호함을 마주하고 추측하려는 유혹을 거절하라. 비록 당신이 우둔해서 처음에는 명백해 보이지 않을 수도 있겠지만 문제를 해결할 하나의 - 바람직하고 유일한 - 명백한 방법이 있을 것이다.\n\n비록 하지않는 것이 지금 하는 것보다 나을 때도 있지만 지금 하는 것이 전혀 안하는 것보다 낫다.\n\n설명하기 어려운 구현이라면 좋은 아이디어가 아니다. 쉽게 설명할 수 있는 구현이라면 좋은 아이디어일 수 있다. 네임스페이스는 정말 대단한 아이디어다. -- 자주 사용하자!\n\nfrom [출처](https://wikidocs.net/7907)\n\n다행히도 Pyplot은 상태 머신을 완전히 무시할 수 있게끔 해 줍니다. 따라서 아름다운 명시적 코드를 작성하는것이 가능하죠. 간단히 `subplots` 함수를 호출해서 반환되는 figure 객체 및 축의 리스트를 사용하면 됩니다*. 마법은 더 이상 없습니다!\n\n> 이제현 주:\n* 여기서 설명하는 부분이 `matplotlib`의 `object oriented API`(객체지향 인터페이스)입니다.\n\n아래는 이에 대한 예 입니다:\n\n일관성을 위해서 이 튜토리얼의 나머지 부분에서는 pyplot의 상태 머신을 계속해서 사용할 것입니다. 그러나 프로그램에서는 객체지향 인터페이스의 사용을 권장하고 싶습니다.\n\n## Pylab *vs* Pyplot *vs* Matplotlib\n\npylab, pyplot, matplotlib 간의 관계에대한 혼동이 있습니다. 그러나 이들의 관계는 매우 단순합니다: matplotlib은 완전한 라이브러리이며, pylab 및 pyplot을 포함한 모든것을 가지고 있습니다.\n\nPyplot은 그래프를 그리기위한 다양한 도구를 제공합니다. 여기에는 내부적인 객체지향적인 그래프 그리기 라이브러리에 대한 상태 머신 인터페이스도 포함됩니다.\n\nPylab은 mkatplotlib.pyplot 및 NumPy를 단일 네임스페이스로 임포트하는 편리성을 위한 모듈입니다. 인터넷에 떠도는 pylab을 사용하는 여러 예제를 보게 될 것입니다. 그러나 이는 더이상 권장되는 사용방법은 아닙니다 (왜냐하면 *명시적*인 임포트가 *암시적인*것 보다 더 낫기 때문입니다).\n\n> 이제현 주 :\n* Pylab, Pyplot, Object oriented API의 관계는 [여기](https://matplotlib.org/3.2.1/api/index.html)를 참고하십시오\n\n## 텍스트 그리기\n`text` 함수를 호출하여 텍스트를 그래프의 원하는 위치에 추가할 수 있습니다. 출력을 원하는 텍스트와 수평 및 수직 좌표를 지정하고, 추가적으로 몇 가지 속성을 지정해 주기만 하면 됩니다. matplotlib의 모든 텍스트는 TeX 방정식 표현을 포함할 수 있습니다. 더 자세한 내용은 [공식 문서](http://matplotlib.org/users/mathtext.html)를 참조하시기 바랍니다.\n\n* 알아둘 것: `ha`는 `horizontalalignment(수평정렬)`의 이명 입니다.\n\n더 많은 텍스트 속성을 알고 싶다면, [공식 문서](http://matplotlib.org/users/text_props.html#text-properties)를 참조하시기 바랍니다.\n\n아래 그래프의 \"beautiful point\" 같은 텍스트 처럼, 그래프의 요소에 주석을 다는것은 꽤 흔한 일입니다. `annotate` 함수는 이를 쉽게 할 수 있게 해 줍니다: 관심있는 부분의 위치를 지정하고, 텍스트의 위치를 지정합니다. 그리고 텍스트 및 화살표에 대한 추가적인 속성도 지정해줄 수 있습니다.\n\n`bbox` 속성을 사용하면, 텍스트를 포함하는 사각형을 그려볼 수도 있습니다:\n\n재미를 위해서 [xkcd](http://xkcd.com) 스타일의 그래프를 그려보고 싶다면, `with plt.xkcd()` 섹션 블록을 활용할 수도 있습니다:\n\n## 범례 (Legends)\n\n범례를 추가하는 가장 간단한 방법은 모든 선에 라벨을 설정해주고, `legend` 함수를 호출하는 것입니다.\n\n## 비선형 척도\n\nMatplotlib은 로그, 로짓(logit)과 같은 비선형 척도를 지원합니다.\n\n## 틱과 틱커 (Ticks and tickers)\n\n각 축에는 \"틱(ticks)\"이라는 작은 표시가 있습니다. 정확히 말하자면, \"틱\"은 표시(예. (-1, 0, 1))의 *위치*\"이며, *틱 선*은 그 위치에 그려지는 작은 선입니다. 또한 \"틱 라벨\"은 틱 선 옆에 그려지는 라벨이며, \"틱커\"는 틱의 위치를 결정하는 객체 입니다. 기본적인 틱커는 ~5 에서 8 틱을 위치시키는데 꽤 잘 작동합니다. 즉, 틱 서로간에 적당한 거리를 표현합니다.\n\n하지만, 가끔은 좀 더 이를 제어할 필요가 있습니다 (예. 위의 로짓 그래프에서는 너무 많은 틱 라벨이 있습니다). 다행히도 matplotlib은 틱을 완전히 제어하는 방법을 제공합니다. 심지어 보조 눈금(minor tick)을 활성화 할 수도 있습니다.\n\n\n## 극좌표계의 투영 (Polar projection)\n\n극좌표계 그래프를 그리는 것은 매우 간단합니다. 부분 그래프를 생성할 때 `projection` 속성을 `\"polar\"`로 설정해 주기만 하면 됩니다.\n\n> 이제현 주:   \n* `object oriented API`는 일반적으로 `plt.subplots()`로 `Figure`와 `Axes` 객체를 동시에 생성합니다.\n* `plt.subplots()`는 `projection` 속성을 가지고 있지 않습니다.\n* 따라서 `projection`을 사용할 때는 `plt.figure()`로 `Figure` 객체를 먼저 생성한 후 `plt.subplot()`이나 `plt.add_subplot()`으로 `Axes` 객체를 추가해 주거나,\n  `fig.subplots()` 안에 `subplot_kw=={'polar':True}`로 지정해 주어야 합니다.\n\n## 3차원 투영\n\n3차원 그래프를 그리는것은 꽤 간단합니다. 우선 `\"3d\"` 투영을 등록하는 `Axes3D`를 임포트 해줘야 합니다. 그리곤 `projection` 속성을 `\"3d\"`로 설정된 부분 그래프 생성합니다. 그러면 `Axes3DSubplot` 이라는 객체가 반환되는데, 이 객체의 `plot_surface` 메서드를 호출하면 x, y, z 좌표를 포함한 추가적이나 속성을 지정할 수 있습니다.\n\n동일한 데이터를 출력하는 또 다른 방법은 등고선도(contour plot)를 *이용*하는 것입니다.\n\n## 산점도 (Scatter plot)\n\n단순히 각 점에 대한 x 및 y 좌표를 제공하면 산점도를 그릴 수 있습니다.\n\n부수적으로 각 점의 크기를 정할 수도 있습니다.\n\n마찬가지로 여러 속성을 설정할 수 있습니다. 가령 테두리 및 모양의 내부 색상, 그리고 투명도와 같은것의 설정이 가능합니다.\n\n## 선\n\n지금까지 해온것 처럼 `plot` 함수를 사용하여 선을 그릴 수 있습니다. 하지만, 가끔은 그래프를 통과하는 무한한 선을 그리는 유틸리티 함수를 만들면 편리합니다 (기울기와 절편으로). 또한 `hlines` 및 `vlines` 함수를 사용하면, 아래와 같이 부분 수평 및 수직 선을 그릴 수도 있습니다:\n\n## 히스토그램\n\n## 이미지\n\nmatplotlib에서의 이미지 불러오기, 생성하기, 화면에 그리기는 꽤 간단합니다.\n\n이미지를 불러오려면 `matplotlib.image` 모듈을 임포트하고, 파일이름을 지정한 `imread` 함수를 호출해 주면 됩니다. 그러면 이미지 데이터가 NumPy의 배열로서 반환됩니다. 앞서 저장했던 `my_square_function.png` 이미지에 대하여 이를 수행해 보겠습니다.\n\n> 이제현 주 :\n* 이미지 단독 출력은 `pyplot`과 `object oriented API` 사이에 별 차이가 없습니다.\n* `Axes`를 지정해서 출력하는 것이 다를 뿐입니다.\n* `pyplot`과의 중복성이 강하지만 익숙해지는 차원에서 `object oriented API`를 함께 도시합니다.\n\n\n288x432 크기의 이미지를 불러왔습니다. 각 픽셀은 0~1 사이의 32비트 부동소수 값인 4개의 요소(빨강, 초록, 파랑, 투명도)로 구성된 배열로 표현됩니다. 이번에는 `imshow`함수를 호출해 보겠습니다:\n\n허허허... 이미지 출력에 포함된 축을 숨기고 싶다면 아래와 같이 축을 off 시켜줄 수 있습니다:\n\n여러분만의 이미지를 생성하는것도 마찬가지로 간단합니다:\n\nRGB 수준을 제공하지 않는다면, `imshow` 함수는 자동으로 값을 색그래디언트에 매핑합니다. 기본적인 동작에서의 색그래디언트는 파랑(낮은 값) 에서 빨강(높은 값)으로 움직입니다. 하지만 아래와 같이 다른 색상맵을 선택할 수도 있습니다:\n\nRGB 이미지를 직접적으로 생성하는것 또한 가능합니다:\n\n`img` 배열이 매우 작기 때문에 (20x30), `imshow` 함수는 이미지를 figure 크기에 맞도록 늘려버린채 출력합니다. 이러한 늘리기의 기본 동작은 [쌍선형 보간법(bilinear interpolation)](https://en.wikipedia.org/wiki/Bilinear_interpolation)을 사용하여 추가된 픽셀을 매꿉니다. 테두리가 흐릿한 이유입니다.\n\n다른 보간법 알고리즘을 선택할 수도 있습니다. 가령 아래와 같이 근접 픽셀을 복사하는 방법이 있습니다:\n\n> 이제현 주 :\n* 위 코드의 `ax.imshow(img, interpolation='bilinear')` 부분은 원문에서 `ax.imshow(img)`로 되어 있습니다.\n* `matplotlib` 2.0 이전에는 `interpolation='bilinear'`가 기본값이기 때문에 경계선이 흐려지는 문제가 있었습니다.\n* 그러나 이후 `interpolation='nearest'`로 기본값이 변경되어 흐려지는 문제가 더 이상 발생하지 않습니다.\n* 자세한 사항은 [이 글](https://matplotlib.org/3.2.1/users/prev_whats_new/whats_new_2.0.0.html)을 참고하십시오.\n\n## 애니메이션\n\nmatplotlib은 이미지 생성에 주로 사용되지만, 애니메이션의 출력도 가능합니다. 우선 `matplotlib.animation`을 임포트 해 줘야 합니다. 그 다음은 (주피터 노트북에서) `nbagg`를 백엔드로 설정하거나, 아래의 코드를 실행해 주면 됩니다.\n\n다음의 예는 데이터를 생성하는것으로 시작됩니다. 그 다음, 빈 그래프를 생성하고, 애니메이션을 그릴 매 프레임 마다 호출될 갱신(update) 함수를 정의합니다. 마지막으로, `FuncAnimation` 인스턴스를 생성하여 그래프에 애니메이션을 추가합니다.\n\n`FuncAnimation` 생성자는 figure, 갱신 함수, 그 외의 파라미터를 수용합니다. 각 프레임간 20ms의 시간차가 있는 100개의 프레임으로 구성된 애니메이션에 대한 인스턴스를 만들었습니다. 애니메이션의 각 프레임마다 `FuncAnimation` 는 갱신 함수를 호출하고, 프레임 번호를 `num` (이 예에서는 0~99의 범위) 으로서 전달해 줍니다. 또한 갱신 함수의 추가적인 두 파라미터는 FuncAnimation 생성시 `fargs`에 넣어준 값이 됩니다.\n\n작성한 갱신 함수는 선을 구성하는 데이터를 0 ~ `num` 데이터로 설정합니다 (따라서 데이터가 점진적으로 그려집니다). 그리고 약간의 재미 요소를 위해서, 각 데이터에 약간의 무작위 수를 추가하여 선이 씰룩씰룩 움직이게끔 해 주었습니다.\n\n## 애니메이션을 비디오로 저장\n비디오로 저장하기 위해서 Matplotlib은 써드파티 라이브러리([FFMPEG](https://www.ffmpeg.org/) 또는 [ImageMagick](https://imagemagick.org/)에 의존합니다. 다음의 예는 FFMPEG를 사용하기 때문에, 이 라이브러리가 먼저 설치되어 있어야만 합니다. 애니메이션을 GIF로 저장하고 싶다면 ImageMagick이 필요할 것입니다.\n\n##  MCS로 파이 구하기\n\nref: <https://clauswilke.com/dataviz/>\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../styles.css"],"toc":true,"output-file":"2023-09-19-graph2.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.315","theme":"cosmo","code-copy":true,"title-block-banner":true,"title":"3wk-1 그래프2","author":"JiyunLim","date":"09/19/2023"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}