{"title":"**[STBDA]** 11wk. MaxPool2D, Conv2D","markdown":{"yaml":{"title":"**[STBDA]** 11wk. MaxPool2D, Conv2D","author":"JiyunLim","date":"05/30/2023","categories":["빅데이터분석특강"]},"headingText":"강의영상","containsRefs":false,"markdown":"\n\n\n>youtube: https://youtube.com/playlist?list=PLQqh36zP38-wlEuWT75L4hqGNEwoPpjWw\n\n### imports\n\n`-` 첫시도\n\n`-` 두번째 시도 : 네트워크를 다르게 설계\n\n파라미터를 네트워크1에 비해  1.2%정도 밖에 안쓰고 있는데 성능은 더 좋다.\n\n- $x$라는 데이터가 들어가서 6장의 레이어를 순차적으로 통과하는 구조이다.\n\n### MaxPool2D\n\n#### 테스트1\n\n`-` 레이어생성\n\n`-` 입력데이터\n\n`-` 입력데이터가 레이어를 통과한 모습\n\n`-` MaxPool2D layer의 역할: (2,2)윈도우를 만들고 (2,2)윈도우에서 max를 뽑아 값을 기록, 윈도우를 움직이면서 반복\n\n#### 테스트2\n\n#### 테스트3\n\n#### 테스트4\n\n- 차원이 안맞는 부분은 버린다.. (이게 Default)\n\n#### 테스트5\n\n#### 테스트6\n\n### Conv2D\n\n#### 테스트1\n\n`-` 레이어생성\n\n`-` XXX생성\n\n- XXX에서 cnv(XXX)로 가는 맵핑을 찾는건 쉽지 않아보인다.\n- 심지어 랜덤으로 결정되는 부분도 있어보임\n\n`-` 코드정리 + 시드통일\n\n`-` conv의 입출력\n\n`-` conv연산 추론\n\n```python\n\n## XXX\ntf.Tensor(\n[[[ 0.  1.  2.  3.]\n  [ 4.  5.  6.  7.]\n  [ 8.  9. 10. 11.]\n  [12. 13. 14. 15.]]]\n\n## cnv(XXX)\n[[[ 0.36673212 -0.5838206  -1.5343733 ]\n  [-3.4354792  -4.3860326  -5.336584  ]\n  [-7.23769    -8.188243   -9.138796  ]]]\n```\n\n```python\n## cnv.weights\narray([[-0.7749905 , -0.50674176],\n       [ 0.7824232 , -0.45124376]], dtype=float32)>\n```\n\n- weights를 위에 처럼 다 쓰긴 너무 귀찮아..\n\n`-` 내가 정의한 weights를 대입하여 conv 연산 확인\n\n- bias=3\n\n#### tf.keras.layers.Conv2D(1,kernel_size=(2,2)) 요약\n\n`-` 요약\n\n(1) size=(2,2)인 윈도우를 만듬.\n\n(2) XXX에 윈도우를 통과시켜서 (2,2)크기의 sub XXX 를 얻음. sub XXX의 각 원소에 conv2d.weights[0]의 각 원소를 element-wise하게 곱한다.\n\n(3) (2)의 결과를 모두 더한다. 그리고 그 결과에 다시 conv2d.weights[1]을 수행\n\n(4) 윈도우를 이동시키면서 반복!\n\n#### 테스트2\n\n`-` 레이어와 XXX생성\n\n- 하나는 kernel에 대한 weight, 다른 하나는 bias에 대한 weight(=0)\n\n#### 테스트3\n\n![](https://github.com/guebin/2021BDA/blob/master/_notebooks/2021-11-04-conv.png?raw=true)\n\n::: {.callout-warning}\n- dtype은 항상 float\n- shape은 항상 4D로 나와야 한다.\n:::\n\n- 일단 cnv(XXX) 이걸 돌려줘야 weight이 생긴다.\n\n- layer에 통과하는 순간 weight이 정의된다.\n\n- bias는 $0$이니까 무시..\n\n#### 테스트4: X의 channel, Conv channel 늘려보기.\n\n```python\n## 첫번째 observation\n[[[ 0.  1.  2.  3.  4.]\n  [ 5.  6.  7.  8.  9.]\n  [10. 11. 12. 13. 14.]\n  [15. 16. 17. 18. 19.]\n  [20. 21. 22. 23. 24.]]\n\n ## 두번째 observation\n [[25. 26. 27. 28. 29.]\n  [30. 31. 32. 33. 34.]\n  [35. 36. 37. 38. 39.]\n  [40. 41. 42. 43. 44.]\n  [45. 46. 47. 48. 49.]]]\n```\n\n- 첫번째 obs에 컨볼루션 연산, 두번째 obs도 반복..\n\n#### 테스트5 : obs 그대로(고정), 출력 채널이 바뀔 때\n\n`-` 여기부터 어려워짐..\n\n- 1개의 채널에서 4개의 채널로 뻥튀기 됨.\n\n`-` 계산결과를 확인하기 쉽게 하기 위한 약간의 트릭\n\n- 이렇게 XXX를 설정하면 cnv(XXX)의 결과는 단지 cnv의 weight들의 sum이 된다.\n\n#### 테스트6\n\n`-` 결과확인을 쉽게하기 위해서 XXX를 1로 통일\n\n### hw\n\n아래와 같은 흑백이미지가 있다고 하자.\n```\n0 0 0 1 1 1\n0 0 0 1 1 1\n0 0 0 1 1 1\n0 0 0 1 1 1\n0 0 0 1 1 1\n0 0 0 1 1 1\n```\n\n위의 이미지에 아래와 같은 weight를 가진 필터를 적용하여 convolution한 결과를 계산하라. (bias는 0으로 가정한다)\n```\n-1 1\n-1 1\n```\n","srcMarkdownNoYaml":"\n\n### 강의영상\n\n>youtube: https://youtube.com/playlist?list=PLQqh36zP38-wlEuWT75L4hqGNEwoPpjWw\n\n### imports\n\n`-` 첫시도\n\n`-` 두번째 시도 : 네트워크를 다르게 설계\n\n파라미터를 네트워크1에 비해  1.2%정도 밖에 안쓰고 있는데 성능은 더 좋다.\n\n- $x$라는 데이터가 들어가서 6장의 레이어를 순차적으로 통과하는 구조이다.\n\n### MaxPool2D\n\n#### 테스트1\n\n`-` 레이어생성\n\n`-` 입력데이터\n\n`-` 입력데이터가 레이어를 통과한 모습\n\n`-` MaxPool2D layer의 역할: (2,2)윈도우를 만들고 (2,2)윈도우에서 max를 뽑아 값을 기록, 윈도우를 움직이면서 반복\n\n#### 테스트2\n\n#### 테스트3\n\n#### 테스트4\n\n- 차원이 안맞는 부분은 버린다.. (이게 Default)\n\n#### 테스트5\n\n#### 테스트6\n\n### Conv2D\n\n#### 테스트1\n\n`-` 레이어생성\n\n`-` XXX생성\n\n- XXX에서 cnv(XXX)로 가는 맵핑을 찾는건 쉽지 않아보인다.\n- 심지어 랜덤으로 결정되는 부분도 있어보임\n\n`-` 코드정리 + 시드통일\n\n`-` conv의 입출력\n\n`-` conv연산 추론\n\n```python\n\n## XXX\ntf.Tensor(\n[[[ 0.  1.  2.  3.]\n  [ 4.  5.  6.  7.]\n  [ 8.  9. 10. 11.]\n  [12. 13. 14. 15.]]]\n\n## cnv(XXX)\n[[[ 0.36673212 -0.5838206  -1.5343733 ]\n  [-3.4354792  -4.3860326  -5.336584  ]\n  [-7.23769    -8.188243   -9.138796  ]]]\n```\n\n```python\n## cnv.weights\narray([[-0.7749905 , -0.50674176],\n       [ 0.7824232 , -0.45124376]], dtype=float32)>\n```\n\n- weights를 위에 처럼 다 쓰긴 너무 귀찮아..\n\n`-` 내가 정의한 weights를 대입하여 conv 연산 확인\n\n- bias=3\n\n#### tf.keras.layers.Conv2D(1,kernel_size=(2,2)) 요약\n\n`-` 요약\n\n(1) size=(2,2)인 윈도우를 만듬.\n\n(2) XXX에 윈도우를 통과시켜서 (2,2)크기의 sub XXX 를 얻음. sub XXX의 각 원소에 conv2d.weights[0]의 각 원소를 element-wise하게 곱한다.\n\n(3) (2)의 결과를 모두 더한다. 그리고 그 결과에 다시 conv2d.weights[1]을 수행\n\n(4) 윈도우를 이동시키면서 반복!\n\n#### 테스트2\n\n`-` 레이어와 XXX생성\n\n- 하나는 kernel에 대한 weight, 다른 하나는 bias에 대한 weight(=0)\n\n#### 테스트3\n\n![](https://github.com/guebin/2021BDA/blob/master/_notebooks/2021-11-04-conv.png?raw=true)\n\n::: {.callout-warning}\n- dtype은 항상 float\n- shape은 항상 4D로 나와야 한다.\n:::\n\n- 일단 cnv(XXX) 이걸 돌려줘야 weight이 생긴다.\n\n- layer에 통과하는 순간 weight이 정의된다.\n\n- bias는 $0$이니까 무시..\n\n#### 테스트4: X의 channel, Conv channel 늘려보기.\n\n```python\n## 첫번째 observation\n[[[ 0.  1.  2.  3.  4.]\n  [ 5.  6.  7.  8.  9.]\n  [10. 11. 12. 13. 14.]\n  [15. 16. 17. 18. 19.]\n  [20. 21. 22. 23. 24.]]\n\n ## 두번째 observation\n [[25. 26. 27. 28. 29.]\n  [30. 31. 32. 33. 34.]\n  [35. 36. 37. 38. 39.]\n  [40. 41. 42. 43. 44.]\n  [45. 46. 47. 48. 49.]]]\n```\n\n- 첫번째 obs에 컨볼루션 연산, 두번째 obs도 반복..\n\n#### 테스트5 : obs 그대로(고정), 출력 채널이 바뀔 때\n\n`-` 여기부터 어려워짐..\n\n- 1개의 채널에서 4개의 채널로 뻥튀기 됨.\n\n`-` 계산결과를 확인하기 쉽게 하기 위한 약간의 트릭\n\n- 이렇게 XXX를 설정하면 cnv(XXX)의 결과는 단지 cnv의 weight들의 sum이 된다.\n\n#### 테스트6\n\n`-` 결과확인을 쉽게하기 위해서 XXX를 1로 통일\n\n### hw\n\n아래와 같은 흑백이미지가 있다고 하자.\n```\n0 0 0 1 1 1\n0 0 0 1 1 1\n0 0 0 1 1 1\n0 0 0 1 1 1\n0 0 0 1 1 1\n0 0 0 1 1 1\n```\n\n위의 이미지에 아래와 같은 weight를 가진 필터를 적용하여 convolution한 결과를 계산하라. (bias는 0으로 가정한다)\n```\n-1 1\n-1 1\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"2022_05_16_(11주차)_5월16일.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.315","theme":"cosmo","code-copy":true,"title-block-banner":true,"title":"**[STBDA]** 11wk. MaxPool2D, Conv2D","author":"JiyunLim","date":"05/30/2023","categories":["빅데이터분석특강"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}